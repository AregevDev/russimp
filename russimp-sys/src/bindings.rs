/* automatically generated by rust-bindgen 0.55.1 */

pub type __uint32_t = ::std::os::raw::c_uint;
pub type ai_real = f32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiVector3D {
    pub x: ai_real,
    pub y: ai_real,
    pub z: ai_real,
}
#[test]
fn bindgen_test_layout_aiVector3D() {
    assert_eq!(
        ::std::mem::size_of::<aiVector3D>(),
        12usize,
        concat!("Size of: ", stringify!(aiVector3D))
    );
    assert_eq!(
        ::std::mem::align_of::<aiVector3D>(),
        4usize,
        concat!("Alignment of ", stringify!(aiVector3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVector3D>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVector3D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVector3D>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVector3D),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVector3D>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVector3D),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiVector2D {
    pub x: ai_real,
    pub y: ai_real,
}
#[test]
fn bindgen_test_layout_aiVector2D() {
    assert_eq!(
        ::std::mem::size_of::<aiVector2D>(),
        8usize,
        concat!("Size of: ", stringify!(aiVector2D))
    );
    assert_eq!(
        ::std::mem::align_of::<aiVector2D>(),
        4usize,
        concat!("Alignment of ", stringify!(aiVector2D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVector2D>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVector2D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVector2D>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVector2D),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiColor4D {
    pub r: ai_real,
    pub g: ai_real,
    pub b: ai_real,
    pub a: ai_real,
}
#[test]
fn bindgen_test_layout_aiColor4D() {
    assert_eq!(
        ::std::mem::size_of::<aiColor4D>(),
        16usize,
        concat!("Size of: ", stringify!(aiColor4D))
    );
    assert_eq!(
        ::std::mem::align_of::<aiColor4D>(),
        4usize,
        concat!("Alignment of ", stringify!(aiColor4D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiColor4D>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiColor4D),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiColor4D>())).g as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiColor4D),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiColor4D>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiColor4D),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiColor4D>())).a as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aiColor4D),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiMatrix4x4 {
    pub a1: ai_real,
    pub a2: ai_real,
    pub a3: ai_real,
    pub a4: ai_real,
    pub b1: ai_real,
    pub b2: ai_real,
    pub b3: ai_real,
    pub b4: ai_real,
    pub c1: ai_real,
    pub c2: ai_real,
    pub c3: ai_real,
    pub c4: ai_real,
    pub d1: ai_real,
    pub d2: ai_real,
    pub d3: ai_real,
    pub d4: ai_real,
}
#[test]
fn bindgen_test_layout_aiMatrix4x4() {
    assert_eq!(
        ::std::mem::size_of::<aiMatrix4x4>(),
        64usize,
        concat!("Size of: ", stringify!(aiMatrix4x4))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMatrix4x4>(),
        4usize,
        concat!("Alignment of ", stringify!(aiMatrix4x4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).a1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(a1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).a2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(a2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).a3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(a3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).a4 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(a4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).b1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(b1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).b2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(b2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).b3 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(b3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).b4 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(b4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).c1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(c1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).c2 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(c2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).c3 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(c3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).c4 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(c4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).d1 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(d1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).d2 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(d2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).d3 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(d3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMatrix4x4>())).d4 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMatrix4x4),
            "::",
            stringify!(d4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiQuaternion {
    pub w: ai_real,
    pub x: ai_real,
    pub y: ai_real,
    pub z: ai_real,
}
#[test]
fn bindgen_test_layout_aiQuaternion() {
    assert_eq!(
        ::std::mem::size_of::<aiQuaternion>(),
        16usize,
        concat!("Size of: ", stringify!(aiQuaternion))
    );
    assert_eq!(
        ::std::mem::align_of::<aiQuaternion>(),
        4usize,
        concat!("Alignment of ", stringify!(aiQuaternion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiQuaternion>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiQuaternion),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiQuaternion>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiQuaternion),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiQuaternion>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiQuaternion),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiQuaternion>())).z as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aiQuaternion),
            "::",
            stringify!(z)
        )
    );
}
pub type ai_uint32 = u32;
#[doc = " Represents a color in Red-Green-Blue space."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiColor3D {
    #[doc = "! Red, green and blue color values"]
    pub r: ai_real,
    #[doc = "! Red, green and blue color values"]
    pub g: ai_real,
    #[doc = "! Red, green and blue color values"]
    pub b: ai_real,
}
#[test]
fn bindgen_test_layout_aiColor3D() {
    assert_eq!(
        ::std::mem::size_of::<aiColor3D>(),
        12usize,
        concat!("Size of: ", stringify!(aiColor3D))
    );
    assert_eq!(
        ::std::mem::align_of::<aiColor3D>(),
        4usize,
        concat!("Alignment of ", stringify!(aiColor3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiColor3D>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiColor3D),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiColor3D>())).g as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiColor3D),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiColor3D>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiColor3D),
            "::",
            stringify!(b)
        )
    );
}
#[doc = " Represents an UTF-8 string, zero byte terminated."]
#[doc = ""]
#[doc = "  The character set of an aiString is explicitly defined to be UTF-8. This Unicode"]
#[doc = "  transformation was chosen in the belief that most strings in 3d files are limited"]
#[doc = "  to ASCII, thus the character set needed to be strictly ASCII compatible."]
#[doc = ""]
#[doc = "  Most text file loaders provide proper Unicode input file handling, special unicode"]
#[doc = "  characters are correctly transcoded to UTF8 and are kept throughout the libraries'"]
#[doc = "  import pipeline."]
#[doc = ""]
#[doc = "  For most applications, it will be absolutely sufficient to interpret the"]
#[doc = "  aiString as ASCII data and work with it as one would work with a plain char*."]
#[doc = "  Windows users in need of proper support for i.e asian characters can use the"]
#[doc = "  MultiByteToWideChar(), WideCharToMultiByte() WinAPI functionality to convert the"]
#[doc = "  UTF-8 strings to their working character set (i.e. MBCS, WideChar)."]
#[doc = ""]
#[doc = "  We use this representation instead of std::string to be C-compatible. The"]
#[doc = "  (binary) length of such a string is limited to MAXLEN characters (including the"]
#[doc = "  the terminating zero)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aiString {
    #[doc = " Binary length of the string excluding the terminal 0. This is NOT the"]
    #[doc = "  logical length of strings containing UTF-8 multi-byte sequences! It's"]
    #[doc = "  the number of bytes from the beginning of the string to its end."]
    pub length: ai_uint32,
    #[doc = " String buffer. Size limit is MAXLEN"]
    pub data: [::std::os::raw::c_char; 1024usize],
}
#[test]
fn bindgen_test_layout_aiString() {
    assert_eq!(
        ::std::mem::size_of::<aiString>(),
        1028usize,
        concat!("Size of: ", stringify!(aiString))
    );
    assert_eq!(
        ::std::mem::align_of::<aiString>(),
        4usize,
        concat!("Alignment of ", stringify!(aiString))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiString>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiString),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiString>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiString),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Reads the given file and returns its content."]
    #[doc = ""]
    #[doc = " If the call succeeds, the imported data is returned in an aiScene structure."]
    #[doc = " The data is intended to be read-only, it stays property of the ASSIMP"]
    #[doc = " library and will be stable until aiReleaseImport() is called. After you're"]
    #[doc = " done with it, call aiReleaseImport() to free the resources associated with"]
    #[doc = " this file. If the import fails, NULL is returned instead. Call"]
    #[doc = " aiGetErrorString() to retrieve a human-readable error text."]
    #[doc = " @param pFile Path and filename of the file to be imported,"]
    #[doc = "   expected to be a null-terminated c-string. NULL is not a valid value."]
    #[doc = " @param pFlags Optional post processing steps to be executed after"]
    #[doc = "   a successful import. Provide a bitwise combination of the"]
    #[doc = "   #aiPostProcessSteps flags."]
    #[doc = " @return Pointer to the imported data or NULL if the import failed."]
    pub fn aiImportFile(
        pFile: *const ::std::os::raw::c_char,
        pFlags: ::std::os::raw::c_uint,
    ) -> *const aiScene;
}
extern "C" {
    #[doc = " Releases all resources associated with the given import process."]
    #[doc = ""]
    #[doc = " Call this function after you're done with the imported data."]
    #[doc = " @param pScene The imported data to release. NULL is a valid value."]
    pub fn aiReleaseImport(pScene: *const aiScene);
}
extern "C" {
    #[doc = " Returns the error text of the last failed import process."]
    #[doc = ""]
    #[doc = " @return A textual description of the error that occurred at the last"]
    #[doc = " import process. NULL if there was no error. There can't be an error if you"]
    #[doc = " got a non-NULL #aiScene from #aiImportFile/#aiImportFileEx/#aiApplyPostProcessing."]
    pub fn aiGetErrorString() -> *const ::std::os::raw::c_char;
}
#[doc = " <hr>Calculates the tangents and bitangents for the imported meshes."]
#[doc = ""]
#[doc = " Does nothing if a mesh does not have normals. You might want this post"]
#[doc = " processing step to be executed if you plan to use tangent space calculations"]
#[doc = " such as normal mapping  applied to the meshes. There's an importer property,"]
#[doc = " <tt>#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</tt>, which allows you to specify"]
#[doc = " a maximum smoothing angle for the algorithm. However, usually you'll"]
#[doc = " want to leave it at the default value."]
pub const aiPostProcessSteps_aiProcess_CalcTangentSpace: aiPostProcessSteps = 1;
#[doc = " <hr>Identifies and joins identical vertex data sets within all"]
#[doc = "  imported meshes."]
#[doc = ""]
#[doc = " After this step is run, each mesh contains unique vertices,"]
#[doc = " so a vertex may be used by multiple faces. You usually want"]
#[doc = " to use this post processing step. If your application deals with"]
#[doc = " indexed geometry, this step is compulsory or you'll just waste rendering"]
#[doc = " time. <b>If this flag is not specified</b>, no vertices are referenced by"]
#[doc = " more than one face and <b>no index buffer is required</b> for rendering."]
pub const aiPostProcessSteps_aiProcess_JoinIdenticalVertices: aiPostProcessSteps = 2;
#[doc = " <hr>Converts all the imported data to a left-handed coordinate space."]
#[doc = ""]
#[doc = " By default the data is returned in a right-handed coordinate space (which"]
#[doc = " OpenGL prefers). In this space, +X points to the right,"]
#[doc = " +Z points towards the viewer, and +Y points upwards. In the DirectX"]
#[doc = " coordinate space +X points to the right, +Y points upwards, and +Z points"]
#[doc = " away from the viewer."]
#[doc = ""]
#[doc = " You'll probably want to consider this flag if you use Direct3D for"]
#[doc = " rendering. The #aiProcess_ConvertToLeftHanded flag supersedes this"]
#[doc = " setting and bundles all conversions typically required for D3D-based"]
#[doc = " applications."]
pub const aiPostProcessSteps_aiProcess_MakeLeftHanded: aiPostProcessSteps = 4;
#[doc = " <hr>Triangulates all faces of all meshes."]
#[doc = ""]
#[doc = " By default the imported mesh data might contain faces with more than 3"]
#[doc = " indices. For rendering you'll usually want all faces to be triangles."]
#[doc = " This post processing step splits up faces with more than 3 indices into"]
#[doc = " triangles. Line and point primitives are *not* modified! If you want"]
#[doc = " 'triangles only' with no other kinds of primitives, try the following"]
#[doc = " solution:"]
#[doc = " <ul>"]
#[doc = " <li>Specify both #aiProcess_Triangulate and #aiProcess_SortByPType </li>"]
#[doc = " <li>Ignore all point and line meshes when you process assimp's output</li>"]
#[doc = " </ul>"]
pub const aiPostProcessSteps_aiProcess_Triangulate: aiPostProcessSteps = 8;
#[doc = " <hr>Removes some parts of the data structure (animations, materials,"]
#[doc = "  light sources, cameras, textures, vertex components)."]
#[doc = ""]
#[doc = " The  components to be removed are specified in a separate"]
#[doc = " importer property, <tt>#AI_CONFIG_PP_RVC_FLAGS</tt>. This is quite useful"]
#[doc = " if you don't need all parts of the output structure. Vertex colors"]
#[doc = " are rarely used today for example... Calling this step to remove unneeded"]
#[doc = " data from the pipeline as early as possible results in increased"]
#[doc = " performance and a more optimized output data structure."]
#[doc = " This step is also useful if you want to force Assimp to recompute"]
#[doc = " normals or tangents. The corresponding steps don't recompute them if"]
#[doc = " they're already there (loaded from the source asset). By using this"]
#[doc = " step you can make sure they are NOT there."]
#[doc = ""]
#[doc = " This flag is a poor one, mainly because its purpose is usually"]
#[doc = " misunderstood. Consider the following case: a 3D model has been exported"]
#[doc = " from a CAD app, and it has per-face vertex colors. Vertex positions can't be"]
#[doc = " shared, thus the #aiProcess_JoinIdenticalVertices step fails to"]
#[doc = " optimize the data because of these nasty little vertex colors."]
#[doc = " Most apps don't even process them, so it's all for nothing. By using"]
#[doc = " this step, unneeded components are excluded as early as possible"]
#[doc = " thus opening more room for internal optimizations."]
pub const aiPostProcessSteps_aiProcess_RemoveComponent: aiPostProcessSteps = 16;
#[doc = " <hr>Generates normals for all faces of all meshes."]
#[doc = ""]
#[doc = " This is ignored if normals are already there at the time this flag"]
#[doc = " is evaluated. Model importers try to load them from the source file, so"]
#[doc = " they're usually already there. Face normals are shared between all points"]
#[doc = " of a single face, so a single point can have multiple normals, which"]
#[doc = " forces the library to duplicate vertices in some cases."]
#[doc = " #aiProcess_JoinIdenticalVertices is *senseless* then."]
#[doc = ""]
#[doc = " This flag may not be specified together with #aiProcess_GenSmoothNormals."]
pub const aiPostProcessSteps_aiProcess_GenNormals: aiPostProcessSteps = 32;
#[doc = " <hr>Generates smooth normals for all vertices in the mesh."]
#[doc = ""]
#[doc = " This is ignored if normals are already there at the time this flag"]
#[doc = " is evaluated. Model importers try to load them from the source file, so"]
#[doc = " they're usually already there."]
#[doc = ""]
#[doc = " This flag may not be specified together with"]
#[doc = " #aiProcess_GenNormals. There's a importer property,"]
#[doc = " <tt>#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</tt> which allows you to specify"]
#[doc = " an angle maximum for the normal smoothing algorithm. Normals exceeding"]
#[doc = " this limit are not smoothed, resulting in a 'hard' seam between two faces."]
#[doc = " Using a decent angle here (e.g. 80 degrees) results in very good visual"]
#[doc = " appearance."]
pub const aiPostProcessSteps_aiProcess_GenSmoothNormals: aiPostProcessSteps = 64;
#[doc = " <hr>Splits large meshes into smaller sub-meshes."]
#[doc = ""]
#[doc = " This is quite useful for real-time rendering, where the number of triangles"]
#[doc = " which can be maximally processed in a single draw-call is limited"]
#[doc = " by the video driver/hardware. The maximum vertex buffer is usually limited"]
#[doc = " too. Both requirements can be met with this step: you may specify both a"]
#[doc = " triangle and vertex limit for a single mesh."]
#[doc = ""]
#[doc = " The split limits can (and should!) be set through the"]
#[doc = " <tt>#AI_CONFIG_PP_SLM_VERTEX_LIMIT</tt> and <tt>#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</tt>"]
#[doc = " importer properties. The default values are <tt>#AI_SLM_DEFAULT_MAX_VERTICES</tt> and"]
#[doc = " <tt>#AI_SLM_DEFAULT_MAX_TRIANGLES</tt>."]
#[doc = ""]
#[doc = " Note that splitting is generally a time-consuming task, but only if there's"]
#[doc = " something to split. The use of this step is recommended for most users."]
pub const aiPostProcessSteps_aiProcess_SplitLargeMeshes: aiPostProcessSteps = 128;
#[doc = " <hr>Removes the node graph and pre-transforms all vertices with"]
#[doc = " the local transformation matrices of their nodes."]
#[doc = ""]
#[doc = " The output scene still contains nodes, however there is only a"]
#[doc = " root node with children, each one referencing only one mesh,"]
#[doc = " and each mesh referencing one material. For rendering, you can"]
#[doc = " simply render all meshes in order - you don't need to pay"]
#[doc = " attention to local transformations and the node hierarchy."]
#[doc = " Animations are removed during this step."]
#[doc = " This step is intended for applications without a scenegraph."]
#[doc = " The step CAN cause some problems: if e.g. a mesh of the asset"]
#[doc = " contains normals and another, using the same material index, does not,"]
#[doc = " they will be brought together, but the first meshes's part of"]
#[doc = " the normal list is zeroed. However, these artifacts are rare."]
#[doc = " @note The <tt>#AI_CONFIG_PP_PTV_NORMALIZE</tt> configuration property"]
#[doc = " can be set to normalize the scene's spatial dimension to the -1...1"]
#[doc = " range."]
pub const aiPostProcessSteps_aiProcess_PreTransformVertices: aiPostProcessSteps = 256;
#[doc = " <hr>Limits the number of bones simultaneously affecting a single vertex"]
#[doc = "  to a maximum value."]
#[doc = ""]
#[doc = " If any vertex is affected by more than the maximum number of bones, the least"]
#[doc = " important vertex weights are removed and the remaining vertex weights are"]
#[doc = " renormalized so that the weights still sum up to 1."]
#[doc = " The default bone weight limit is 4 (defined as <tt>#AI_LMW_MAX_WEIGHTS</tt> in"]
#[doc = " config.h), but you can use the <tt>#AI_CONFIG_PP_LBW_MAX_WEIGHTS</tt> importer"]
#[doc = " property to supply your own limit to the post processing step."]
#[doc = ""]
#[doc = " If you intend to perform the skinning in hardware, this post processing"]
#[doc = " step might be of interest to you."]
pub const aiPostProcessSteps_aiProcess_LimitBoneWeights: aiPostProcessSteps = 512;
#[doc = " <hr>Validates the imported scene data structure."]
#[doc = " This makes sure that all indices are valid, all animations and"]
#[doc = " bones are linked correctly, all material references are correct .. etc."]
#[doc = ""]
#[doc = " It is recommended that you capture Assimp's log output if you use this flag,"]
#[doc = " so you can easily find out what's wrong if a file fails the"]
#[doc = " validation. The validator is quite strict and will find *all*"]
#[doc = " inconsistencies in the data structure... It is recommended that plugin"]
#[doc = " developers use it to debug their loaders. There are two types of"]
#[doc = " validation failures:"]
#[doc = " <ul>"]
#[doc = " <li>Error: There's something wrong with the imported data. Further"]
#[doc = "   postprocessing is not possible and the data is not usable at all."]
#[doc = "   The import fails. #Importer::GetErrorString() or #aiGetErrorString()"]
#[doc = "   carry the error message around.</li>"]
#[doc = " <li>Warning: There are some minor issues (e.g. 1000000 animation"]
#[doc = "   keyframes with the same time), but further postprocessing and use"]
#[doc = "   of the data structure is still safe. Warning details are written"]
#[doc = "   to the log file, <tt>#AI_SCENE_FLAGS_VALIDATION_WARNING</tt> is set"]
#[doc = "   in #aiScene::mFlags</li>"]
#[doc = " </ul>"]
#[doc = ""]
#[doc = " This post-processing step is not time-consuming. Its use is not"]
#[doc = " compulsory, but recommended."]
pub const aiPostProcessSteps_aiProcess_ValidateDataStructure: aiPostProcessSteps = 1024;
#[doc = " <hr>Reorders triangles for better vertex cache locality."]
#[doc = ""]
#[doc = " The step tries to improve the ACMR (average post-transform vertex cache"]
#[doc = " miss ratio) for all meshes. The implementation runs in O(n) and is"]
#[doc = " roughly based on the 'tipsify' algorithm (see <a href=\""]
#[doc = " http://www.cs.princeton.edu/gfx/pubs/Sander_2007_%3ETR/tipsy.pdf\">this"]
#[doc = " paper</a>)."]
#[doc = ""]
#[doc = " If you intend to render huge models in hardware, this step might"]
#[doc = " be of interest to you. The <tt>#AI_CONFIG_PP_ICL_PTCACHE_SIZE</tt>"]
#[doc = " importer property can be used to fine-tune the cache optimization."]
pub const aiPostProcessSteps_aiProcess_ImproveCacheLocality: aiPostProcessSteps = 2048;
#[doc = " <hr>Searches for redundant/unreferenced materials and removes them."]
#[doc = ""]
#[doc = " This is especially useful in combination with the"]
#[doc = " #aiProcess_PreTransformVertices and #aiProcess_OptimizeMeshes flags."]
#[doc = " Both join small meshes with equal characteristics, but they can't do"]
#[doc = " their work if two meshes have different materials. Because several"]
#[doc = " material settings are lost during Assimp's import filters,"]
#[doc = " (and because many exporters don't check for redundant materials), huge"]
#[doc = " models often have materials which are are defined several times with"]
#[doc = " exactly the same settings."]
#[doc = ""]
#[doc = " Several material settings not contributing to the final appearance of"]
#[doc = " a surface are ignored in all comparisons (e.g. the material name)."]
#[doc = " So, if you're passing additional information through the"]
#[doc = " content pipeline (probably using *magic* material names), don't"]
#[doc = " specify this flag. Alternatively take a look at the"]
#[doc = " <tt>#AI_CONFIG_PP_RRM_EXCLUDE_LIST</tt> importer property."]
pub const aiPostProcessSteps_aiProcess_RemoveRedundantMaterials: aiPostProcessSteps = 4096;
#[doc = " <hr>This step tries to determine which meshes have normal vectors"]
#[doc = " that are facing inwards and inverts them."]
#[doc = ""]
#[doc = " The algorithm is simple but effective:"]
#[doc = " the bounding box of all vertices + their normals is compared against"]
#[doc = " the volume of the bounding box of all vertices without their normals."]
#[doc = " This works well for most objects, problems might occur with planar"]
#[doc = " surfaces. However, the step tries to filter such cases."]
#[doc = " The step inverts all in-facing normals. Generally it is recommended"]
#[doc = " to enable this step, although the result is not always correct."]
pub const aiPostProcessSteps_aiProcess_FixInfacingNormals: aiPostProcessSteps = 8192;
#[doc = " <hr>This step splits meshes with more than one primitive type in"]
#[doc = "  homogeneous sub-meshes."]
#[doc = ""]
#[doc = "  The step is executed after the triangulation step. After the step"]
#[doc = "  returns, just one bit is set in aiMesh::mPrimitiveTypes. This is"]
#[doc = "  especially useful for real-time rendering where point and line"]
#[doc = "  primitives are often ignored or rendered separately."]
#[doc = "  You can use the <tt>#AI_CONFIG_PP_SBP_REMOVE</tt> importer property to"]
#[doc = "  specify which primitive types you need. This can be used to easily"]
#[doc = "  exclude lines and points, which are rarely used, from the import."]
pub const aiPostProcessSteps_aiProcess_SortByPType: aiPostProcessSteps = 32768;
#[doc = " <hr>This step searches all meshes for degenerate primitives and"]
#[doc = "  converts them to proper lines or points."]
#[doc = ""]
#[doc = " A face is 'degenerate' if one or more of its points are identical."]
#[doc = " To have the degenerate stuff not only detected and collapsed but"]
#[doc = " removed, try one of the following procedures:"]
#[doc = " <br><b>1.</b> (if you support lines and points for rendering but don't"]
#[doc = "    want the degenerates)<br>"]
#[doc = " <ul>"]
#[doc = "   <li>Specify the #aiProcess_FindDegenerates flag."]
#[doc = "   </li>"]
#[doc = "   <li>Set the <tt>#AI_CONFIG_PP_FD_REMOVE</tt> importer property to"]
#[doc = "       1. This will cause the step to remove degenerate triangles from the"]
#[doc = "       import as soon as they're detected. They won't pass any further"]
#[doc = "       pipeline steps."]
#[doc = "   </li>"]
#[doc = " </ul>"]
#[doc = " <br><b>2.</b>(if you don't support lines and points at all)<br>"]
#[doc = " <ul>"]
#[doc = "   <li>Specify the #aiProcess_FindDegenerates flag."]
#[doc = "   </li>"]
#[doc = "   <li>Specify the #aiProcess_SortByPType flag. This moves line and"]
#[doc = "     point primitives to separate meshes."]
#[doc = "   </li>"]
#[doc = "   <li>Set the <tt>#AI_CONFIG_PP_SBP_REMOVE</tt> importer property to"]
#[doc = "       @code aiPrimitiveType_POINTS | aiPrimitiveType_LINES"]
#[doc = "       @endcode to cause SortByPType to reject point"]
#[doc = "       and line meshes from the scene."]
#[doc = "   </li>"]
#[doc = " </ul>"]
#[doc = ""]
#[doc = " This step also removes very small triangles with a surface area smaller"]
#[doc = " than 10^-6. If you rely on having these small triangles, or notice holes"]
#[doc = " in your model, set the property <tt>#AI_CONFIG_PP_FD_CHECKAREA</tt> to"]
#[doc = " false."]
#[doc = " @note Degenerate polygons are not necessarily evil and that's why"]
#[doc = " they're not removed by default. There are several file formats which"]
#[doc = " don't support lines or points, and some exporters bypass the"]
#[doc = " format specification and write them as degenerate triangles instead."]
pub const aiPostProcessSteps_aiProcess_FindDegenerates: aiPostProcessSteps = 65536;
#[doc = " <hr>This step searches all meshes for invalid data, such as zeroed"]
#[doc = "  normal vectors or invalid UV coords and removes/fixes them. This is"]
#[doc = "  intended to get rid of some common exporter errors."]
#[doc = ""]
#[doc = " This is especially useful for normals. If they are invalid, and"]
#[doc = " the step recognizes this, they will be removed and can later"]
#[doc = " be recomputed, i.e. by the #aiProcess_GenSmoothNormals flag.<br>"]
#[doc = " The step will also remove meshes that are infinitely small and reduce"]
#[doc = " animation tracks consisting of hundreds if redundant keys to a single"]
#[doc = " key. The <tt>AI_CONFIG_PP_FID_ANIM_ACCURACY</tt> config property decides"]
#[doc = " the accuracy of the check for duplicate animation tracks."]
pub const aiPostProcessSteps_aiProcess_FindInvalidData: aiPostProcessSteps = 131072;
#[doc = " <hr>This step converts non-UV mappings (such as spherical or"]
#[doc = "  cylindrical mapping) to proper texture coordinate channels."]
#[doc = ""]
#[doc = " Most applications will support UV mapping only, so you will"]
#[doc = " probably want to specify this step in every case. Note that Assimp is not"]
#[doc = " always able to match the original mapping implementation of the"]
#[doc = " 3D app which produced a model perfectly. It's always better to let the"]
#[doc = " modelling app compute the UV channels - 3ds max, Maya, Blender,"]
#[doc = " LightWave, and Modo do this for example."]
#[doc = ""]
#[doc = " @note If this step is not requested, you'll need to process the"]
#[doc = " <tt>#AI_MATKEY_MAPPING</tt> material property in order to display all assets"]
#[doc = " properly."]
pub const aiPostProcessSteps_aiProcess_GenUVCoords: aiPostProcessSteps = 262144;
#[doc = " <hr>This step applies per-texture UV transformations and bakes"]
#[doc = "  them into stand-alone vtexture coordinate channels."]
#[doc = ""]
#[doc = " UV transformations are specified per-texture - see the"]
#[doc = " <tt>#AI_MATKEY_UVTRANSFORM</tt> material key for more information."]
#[doc = " This step processes all textures with"]
#[doc = " transformed input UV coordinates and generates a new (pre-transformed) UV channel"]
#[doc = " which replaces the old channel. Most applications won't support UV"]
#[doc = " transformations, so you will probably want to specify this step."]
#[doc = ""]
#[doc = " @note UV transformations are usually implemented in real-time apps by"]
#[doc = " transforming texture coordinates at vertex shader stage with a 3x3"]
#[doc = " (homogenous) transformation matrix."]
pub const aiPostProcessSteps_aiProcess_TransformUVCoords: aiPostProcessSteps = 524288;
#[doc = " <hr>This step searches for duplicate meshes and replaces them"]
#[doc = "  with references to the first mesh."]
#[doc = ""]
#[doc = "  This step takes a while, so don't use it if speed is a concern."]
#[doc = "  Its main purpose is to workaround the fact that many export"]
#[doc = "  file formats don't support instanced meshes, so exporters need to"]
#[doc = "  duplicate meshes. This step removes the duplicates again. Please"]
#[doc = "  note that Assimp does not currently support per-node material"]
#[doc = "  assignment to meshes, which means that identical meshes with"]
#[doc = "  different materials are currently *not* joined, although this is"]
#[doc = "  planned for future versions."]
pub const aiPostProcessSteps_aiProcess_FindInstances: aiPostProcessSteps = 1048576;
#[doc = " <hr>A post-processing step to reduce the number of meshes."]
#[doc = ""]
#[doc = "  This will, in fact, reduce the number of draw calls."]
#[doc = ""]
#[doc = "  This is a very effective optimization and is recommended to be used"]
#[doc = "  together with #aiProcess_OptimizeGraph, if possible. The flag is fully"]
#[doc = "  compatible with both #aiProcess_SplitLargeMeshes and #aiProcess_SortByPType."]
pub const aiPostProcessSteps_aiProcess_OptimizeMeshes: aiPostProcessSteps = 2097152;
#[doc = " <hr>A post-processing step to optimize the scene hierarchy."]
#[doc = ""]
#[doc = "  Nodes without animations, bones, lights or cameras assigned are"]
#[doc = "  collapsed and joined."]
#[doc = ""]
#[doc = "  Node names can be lost during this step. If you use special 'tag nodes'"]
#[doc = "  to pass additional information through your content pipeline, use the"]
#[doc = "  <tt>#AI_CONFIG_PP_OG_EXCLUDE_LIST</tt> importer property to specify a"]
#[doc = "  list of node names you want to be kept. Nodes matching one of the names"]
#[doc = "  in this list won't be touched or modified."]
#[doc = ""]
#[doc = "  Use this flag with caution. Most simple files will be collapsed to a"]
#[doc = "  single node, so complex hierarchies are usually completely lost. This is not"]
#[doc = "  useful for editor environments, but probably a very effective"]
#[doc = "  optimization if you just want to get the model data, convert it to your"]
#[doc = "  own format, and render it as fast as possible."]
#[doc = ""]
#[doc = "  This flag is designed to be used with #aiProcess_OptimizeMeshes for best"]
#[doc = "  results."]
#[doc = ""]
#[doc = "  @note 'Crappy' scenes with thousands of extremely small meshes packed"]
#[doc = "  in deeply nested nodes exist for almost all file formats."]
#[doc = "  #aiProcess_OptimizeMeshes in combination with #aiProcess_OptimizeGraph"]
#[doc = "  usually fixes them all and makes them renderable."]
pub const aiPostProcessSteps_aiProcess_OptimizeGraph: aiPostProcessSteps = 4194304;
#[doc = " <hr>This step flips all UV coordinates along the y-axis and adjusts"]
#[doc = " material settings and bitangents accordingly."]
#[doc = ""]
#[doc = " <b>Output UV coordinate system:</b>"]
#[doc = " @code"]
#[doc = " 0y|0y ---------- 1x|0y"]
#[doc = " |                 |"]
#[doc = " |                 |"]
#[doc = " |                 |"]
#[doc = " 0x|1y ---------- 1x|1y"]
#[doc = " @endcode"]
#[doc = ""]
#[doc = " You'll probably want to consider this flag if you use Direct3D for"]
#[doc = " rendering. The #aiProcess_ConvertToLeftHanded flag supersedes this"]
#[doc = " setting and bundles all conversions typically required for D3D-based"]
#[doc = " applications."]
pub const aiPostProcessSteps_aiProcess_FlipUVs: aiPostProcessSteps = 8388608;
#[doc = " <hr>This step adjusts the output face winding order to be CW."]
#[doc = ""]
#[doc = " The default face winding order is counter clockwise (CCW)."]
#[doc = ""]
#[doc = " <b>Output face order:</b>"]
#[doc = " @code"]
#[doc = "       x2"]
#[doc = ""]
#[doc = "                         x0"]
#[doc = "  x1"]
#[doc = " @endcode"]
pub const aiPostProcessSteps_aiProcess_FlipWindingOrder: aiPostProcessSteps = 16777216;
#[doc = " <hr>This step splits meshes with many bones into sub-meshes so that each"]
#[doc = " sub-mesh has fewer or as many bones as a given limit."]
pub const aiPostProcessSteps_aiProcess_SplitByBoneCount: aiPostProcessSteps = 33554432;
#[doc = " <hr>This step removes bones losslessly or according to some threshold."]
#[doc = ""]
#[doc = "  In some cases (i.e. formats that require it) exporters are forced to"]
#[doc = "  assign dummy bone weights to otherwise static meshes assigned to"]
#[doc = "  animated meshes. Full, weight-based skinning is expensive while"]
#[doc = "  animating nodes is extremely cheap, so this step is offered to clean up"]
#[doc = "  the data in that regard."]
#[doc = ""]
#[doc = "  Use <tt>#AI_CONFIG_PP_DB_THRESHOLD</tt> to control this."]
#[doc = "  Use <tt>#AI_CONFIG_PP_DB_ALL_OR_NONE</tt> if you want bones removed if and"]
#[doc = "  only if all bones within the scene qualify for removal."]
pub const aiPostProcessSteps_aiProcess_Debone: aiPostProcessSteps = 67108864;
#[doc = " <hr>This step will perform a global scale of the model."]
#[doc = ""]
#[doc = "  Some importers are providing a mechanism to define a scaling unit for the"]
#[doc = "  model. This post processing step can be used to do so. You need to get the"]
#[doc = "  global scaling from your importer settings like in FBX. Use the flag"]
#[doc = "  AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY from the global property table to configure this."]
#[doc = ""]
#[doc = "  Use <tt>#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</tt> to setup the global scaling factor."]
pub const aiPostProcessSteps_aiProcess_GlobalScale: aiPostProcessSteps = 134217728;
#[doc = " <hr>A postprocessing step to embed of textures."]
#[doc = ""]
#[doc = "  This will remove external data dependencies for textures."]
#[doc = "  If a texture's file does not exist at the specified path"]
#[doc = "  (due, for instance, to an absolute path generated on another system),"]
#[doc = "  it will check if a file with the same name exists at the root folder"]
#[doc = "  of the imported model. And if so, it uses that."]
pub const aiPostProcessSteps_aiProcess_EmbedTextures: aiPostProcessSteps = 268435456;
#[doc = " <hr>A postprocessing step to embed of textures."]
#[doc = ""]
#[doc = "  This will remove external data dependencies for textures."]
#[doc = "  If a texture's file does not exist at the specified path"]
#[doc = "  (due, for instance, to an absolute path generated on another system),"]
#[doc = "  it will check if a file with the same name exists at the root folder"]
#[doc = "  of the imported model. And if so, it uses that."]
pub const aiPostProcessSteps_aiProcess_ForceGenNormals: aiPostProcessSteps = 536870912;
#[doc = " <hr>Drops normals for all faces of all meshes."]
#[doc = ""]
#[doc = " This is ignored if no normals are present."]
#[doc = " Face normals are shared between all points of a single face,"]
#[doc = " so a single point can have multiple normals, which"]
#[doc = " forces the library to duplicate vertices in some cases."]
#[doc = " #aiProcess_JoinIdenticalVertices is *senseless* then."]
#[doc = " This process gives sense back to aiProcess_JoinIdenticalVertices"]
pub const aiPostProcessSteps_aiProcess_DropNormals: aiPostProcessSteps = 1073741824;
pub const aiPostProcessSteps_aiProcess_GenBoundingBoxes: aiPostProcessSteps = 2147483648;
#[doc = " @enum  aiPostProcessSteps"]
#[doc = "  @brief Defines the flags for all possible post processing steps."]
#[doc = ""]
#[doc = "  @note Some steps are influenced by properties set on the Assimp::Importer itself"]
#[doc = ""]
#[doc = "  @see Assimp::Importer::ReadFile()"]
#[doc = "  @see Assimp::Importer::SetPropertyInteger()"]
#[doc = "  @see aiImportFile"]
#[doc = "  @see aiImportFileEx"]
pub type aiPostProcessSteps = ::std::os::raw::c_uint;
#[doc = " @brief Helper structure to represent a texel in a ARGB8888 format"]
#[doc = ""]
#[doc = "  Used by aiTexture."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct aiTexel {
    pub b: ::std::os::raw::c_uchar,
    pub g: ::std::os::raw::c_uchar,
    pub r: ::std::os::raw::c_uchar,
    pub a: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_aiTexel() {
    assert_eq!(
        ::std::mem::size_of::<aiTexel>(),
        4usize,
        concat!("Size of: ", stringify!(aiTexel))
    );
    assert_eq!(
        ::std::mem::align_of::<aiTexel>(),
        1usize,
        concat!("Alignment of ", stringify!(aiTexel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexel>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexel),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexel>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexel),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexel>())).r as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexel),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexel>())).a as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexel),
            "::",
            stringify!(a)
        )
    );
}
#[doc = " Helper structure to describe an embedded texture"]
#[doc = ""]
#[doc = " Normally textures are contained in external files but some file formats embed"]
#[doc = " them directly in the model file. There are two types of embedded textures:"]
#[doc = " 1. Uncompressed textures. The color data is given in an uncompressed format."]
#[doc = " 2. Compressed textures stored in a file format like png or jpg. The raw file"]
#[doc = " bytes are given so the application must utilize an image decoder (e.g. DevIL) to"]
#[doc = " get access to the actual color data."]
#[doc = ""]
#[doc = " Embedded textures are referenced from materials using strings like \"*0\", \"*1\", etc."]
#[doc = " as the texture paths (a single asterisk character followed by the"]
#[doc = " zero-based index of the texture in the aiScene::mTextures array)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aiTexture {
    #[doc = " Width of the texture, in pixels"]
    #[doc = ""]
    #[doc = " If mHeight is zero the texture is compressed in a format"]
    #[doc = " like JPEG. In this case mWidth specifies the size of the"]
    #[doc = " memory area pcData is pointing to, in bytes."]
    pub mWidth: ::std::os::raw::c_uint,
    #[doc = " Height of the texture, in pixels"]
    #[doc = ""]
    #[doc = " If this value is zero, pcData points to an compressed texture"]
    #[doc = " in any format (e.g. JPEG)."]
    pub mHeight: ::std::os::raw::c_uint,
    #[doc = " A hint from the loader to make it easier for applications"]
    #[doc = "  to determine the type of embedded textures."]
    #[doc = ""]
    #[doc = " If mHeight != 0 this member is show how data is packed. Hint will consist of"]
    #[doc = " two parts: channel order and channel bitness (count of the bits for every"]
    #[doc = " color channel). For simple parsing by the viewer it's better to not omit"]
    #[doc = " absent color channel and just use 0 for bitness. For example:"]
    #[doc = " 1. Image contain RGBA and 8 bit per channel, achFormatHint == \"rgba8888\";"]
    #[doc = " 2. Image contain ARGB and 8 bit per channel, achFormatHint == \"argb8888\";"]
    #[doc = " 3. Image contain RGB and 5 bit for R and B channels and 6 bit for G channel, achFormatHint == \"rgba5650\";"]
    #[doc = " 4. One color image with B channel and 1 bit for it, achFormatHint == \"rgba0010\";"]
    #[doc = " If mHeight == 0 then achFormatHint is set set to '\\\\0\\\\0\\\\0\\\\0' if the loader has no additional"]
    #[doc = " information about the texture file format used OR the"]
    #[doc = " file extension of the format without a trailing dot. If there"]
    #[doc = " are multiple file extensions for a format, the shortest"]
    #[doc = " extension is chosen (JPEG maps to 'jpg', not to 'jpeg')."]
    #[doc = " E.g. 'dds\\\\0', 'pcx\\\\0', 'jpg\\\\0'.  All characters are lower-case."]
    #[doc = " The fourth character will always be '\\\\0'."]
    pub achFormatHint: [::std::os::raw::c_char; 9usize],
    #[doc = " Data of the texture."]
    #[doc = ""]
    #[doc = " Points to an array of mWidth * mHeight aiTexel's."]
    #[doc = " The format of the texture data is always ARGB8888 to"]
    #[doc = " make the implementation for user of the library as easy"]
    #[doc = " as possible. If mHeight = 0 this is a pointer to a memory"]
    #[doc = " buffer of size mWidth containing the compressed texture"]
    #[doc = " data. Good luck, have fun!"]
    pub pcData: *mut aiTexel,
    #[doc = " Texture original filename"]
    #[doc = ""]
    #[doc = " Used to get the texture reference"]
    pub mFilename: aiString,
}
#[test]
fn bindgen_test_layout_aiTexture() {
    assert_eq!(
        ::std::mem::size_of::<aiTexture>(),
        1064usize,
        concat!("Size of: ", stringify!(aiTexture))
    );
    assert_eq!(
        ::std::mem::align_of::<aiTexture>(),
        8usize,
        concat!("Alignment of ", stringify!(aiTexture))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexture>())).mWidth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexture),
            "::",
            stringify!(mWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexture>())).mHeight as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexture),
            "::",
            stringify!(mHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexture>())).achFormatHint as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexture),
            "::",
            stringify!(achFormatHint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexture>())).pcData as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexture),
            "::",
            stringify!(pcData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiTexture>())).mFilename as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aiTexture),
            "::",
            stringify!(mFilename)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiAABB {
    pub mMin: aiVector3D,
    pub mMax: aiVector3D,
}
#[test]
fn bindgen_test_layout_aiAABB() {
    assert_eq!(
        ::std::mem::size_of::<aiAABB>(),
        24usize,
        concat!("Size of: ", stringify!(aiAABB))
    );
    assert_eq!(
        ::std::mem::align_of::<aiAABB>(),
        4usize,
        concat!("Alignment of ", stringify!(aiAABB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAABB>())).mMin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAABB),
            "::",
            stringify!(mMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAABB>())).mMax as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAABB),
            "::",
            stringify!(mMax)
        )
    );
}
#[doc = " @brief A single face in a mesh, referring to multiple vertices."]
#[doc = ""]
#[doc = " If mNumIndices is 3, we call the face 'triangle', for mNumIndices > 3"]
#[doc = " it's called 'polygon' (hey, that's just a definition!)."]
#[doc = " <br>"]
#[doc = " aiMesh::mPrimitiveTypes can be queried to quickly examine which types of"]
#[doc = " primitive are actually present in a mesh. The #aiProcess_SortByPType flag"]
#[doc = " executes a special post-processing algorithm which splits meshes with"]
#[doc = " *different* primitive types mixed up (e.g. lines and triangles) in several"]
#[doc = " 'clean' submeshes. Furthermore there is a configuration option ("]
#[doc = " #AI_CONFIG_PP_SBP_REMOVE) to force #aiProcess_SortByPType to remove"]
#[doc = " specific kinds of primitives from the imported scene, completely and forever."]
#[doc = " In many cases you'll probably want to set this setting to"]
#[doc = " @code"]
#[doc = " aiPrimitiveType_LINE|aiPrimitiveType_POINT"]
#[doc = " @endcode"]
#[doc = " Together with the #aiProcess_Triangulate flag you can then be sure that"]
#[doc = " #aiFace::mNumIndices is always 3."]
#[doc = " @note Take a look at the @link data Data Structures page @endlink for"]
#[doc = " more information on the layout and winding order of a face."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiFace {
    #[doc = "! Number of indices defining this face."]
    #[doc = "! The maximum value for this member is #AI_MAX_FACE_INDICES."]
    pub mNumIndices: ::std::os::raw::c_uint,
    #[doc = "! Pointer to the indices array. Size of the array is given in numIndices."]
    pub mIndices: *mut ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_aiFace() {
    assert_eq!(
        ::std::mem::size_of::<aiFace>(),
        16usize,
        concat!("Size of: ", stringify!(aiFace))
    );
    assert_eq!(
        ::std::mem::align_of::<aiFace>(),
        8usize,
        concat!("Alignment of ", stringify!(aiFace))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiFace>())).mNumIndices as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiFace),
            "::",
            stringify!(mNumIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiFace>())).mIndices as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiFace),
            "::",
            stringify!(mIndices)
        )
    );
}
#[doc = " @brief A single influence of a bone on a vertex."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiVertexWeight {
    #[doc = "! Index of the vertex which is influenced by the bone."]
    pub mVertexId: ::std::os::raw::c_uint,
    #[doc = "! The strength of the influence in the range (0...1)."]
    #[doc = "! The influence from all bones at one vertex amounts to 1."]
    pub mWeight: f32,
}
#[test]
fn bindgen_test_layout_aiVertexWeight() {
    assert_eq!(
        ::std::mem::size_of::<aiVertexWeight>(),
        8usize,
        concat!("Size of: ", stringify!(aiVertexWeight))
    );
    assert_eq!(
        ::std::mem::align_of::<aiVertexWeight>(),
        4usize,
        concat!("Alignment of ", stringify!(aiVertexWeight))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVertexWeight>())).mVertexId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVertexWeight),
            "::",
            stringify!(mVertexId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVertexWeight>())).mWeight as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVertexWeight),
            "::",
            stringify!(mWeight)
        )
    );
}
#[doc = " @brief A single bone of a mesh."]
#[doc = ""]
#[doc = "  A bone has a name by which it can be found in the frame hierarchy and by"]
#[doc = "  which it can be addressed by animations. In addition it has a number of"]
#[doc = "  influences on vertices, and a matrix relating the mesh position to the"]
#[doc = "  position of the bone at the time of binding."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aiBone {
    #[doc = "! The name of the bone."]
    pub mName: aiString,
    #[doc = "! The number of vertices affected by this bone."]
    #[doc = "! The maximum value for this member is #AI_MAX_BONE_WEIGHTS."]
    pub mNumWeights: ::std::os::raw::c_uint,
    #[doc = "! The influence weights of this bone, by vertex index."]
    pub mWeights: *mut aiVertexWeight,
    #[doc = " Matrix that transforms from bone space to mesh space in bind pose."]
    #[doc = ""]
    #[doc = " This matrix describes the position of the mesh"]
    #[doc = " in the local space of this bone when the skeleton was bound."]
    #[doc = " Thus it can be used directly to determine a desired vertex position,"]
    #[doc = " given the world-space transform of the bone when animated,"]
    #[doc = " and the position of the vertex in mesh space."]
    #[doc = ""]
    #[doc = " It is sometimes called an inverse-bind matrix,"]
    #[doc = " or inverse bind pose matrix."]
    pub mOffsetMatrix: aiMatrix4x4,
}
#[test]
fn bindgen_test_layout_aiBone() {
    assert_eq!(
        ::std::mem::size_of::<aiBone>(),
        1104usize,
        concat!("Size of: ", stringify!(aiBone))
    );
    assert_eq!(
        ::std::mem::align_of::<aiBone>(),
        8usize,
        concat!("Alignment of ", stringify!(aiBone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiBone>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiBone),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiBone>())).mNumWeights as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(aiBone),
            "::",
            stringify!(mNumWeights)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiBone>())).mWeights as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aiBone),
            "::",
            stringify!(mWeights)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiBone>())).mOffsetMatrix as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(aiBone),
            "::",
            stringify!(mOffsetMatrix)
        )
    );
}
#[doc = " A point primitive."]
#[doc = ""]
#[doc = " This is just a single vertex in the virtual world,"]
#[doc = " #aiFace contains just one index for such a primitive."]
pub const aiPrimitiveType_aiPrimitiveType_POINT: aiPrimitiveType = 1;
#[doc = " A line primitive."]
#[doc = ""]
#[doc = " This is a line defined through a start and an end position."]
#[doc = " #aiFace contains exactly two indices for such a primitive."]
pub const aiPrimitiveType_aiPrimitiveType_LINE: aiPrimitiveType = 2;
#[doc = " A triangular primitive."]
#[doc = ""]
#[doc = " A triangle consists of three indices."]
pub const aiPrimitiveType_aiPrimitiveType_TRIANGLE: aiPrimitiveType = 4;
#[doc = " A higher-level polygon with more than 3 edges."]
#[doc = ""]
#[doc = " A triangle is a polygon, but polygon in this context means"]
#[doc = " \"all polygons that are not triangles\". The \"Triangulate\"-Step"]
#[doc = " is provided for your convenience, it splits all polygons in"]
#[doc = " triangles (which are much easier to handle)."]
pub const aiPrimitiveType_aiPrimitiveType_POLYGON: aiPrimitiveType = 8;
pub const aiPrimitiveType__aiPrimitiveType_Force32Bit: aiPrimitiveType = 2147483647;
#[doc = " @brief Enumerates the types of geometric primitives supported by Assimp."]
#[doc = ""]
#[doc = "  @see aiFace Face data structure"]
#[doc = "  @see aiProcess_SortByPType Per-primitive sorting of meshes"]
#[doc = "  @see aiProcess_Triangulate Automatic triangulation"]
#[doc = "  @see AI_CONFIG_PP_SBP_REMOVE Removal of specific primitive types."]
pub type aiPrimitiveType = ::std::os::raw::c_uint;
#[doc = " @brief An AnimMesh is an attachment to an #aiMesh stores per-vertex"]
#[doc = "  animations for a particular frame."]
#[doc = ""]
#[doc = "  You may think of an #aiAnimMesh as a `patch` for the host mesh, which"]
#[doc = "  replaces only certain vertex data streams at a particular time."]
#[doc = "  Each mesh stores n attached attached meshes (#aiMesh::mAnimMeshes)."]
#[doc = "  The actual relationship between the time line and anim meshes is"]
#[doc = "  established by #aiMeshAnim, which references singular mesh attachments"]
#[doc = "  by their ID and binds them to a time offset."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aiAnimMesh {
    #[doc = "Anim Mesh name"]
    pub mName: aiString,
    #[doc = " Replacement for aiMesh::mVertices. If this array is non-NULL,"]
    #[doc = "  it *must* contain mNumVertices entries. The corresponding"]
    #[doc = "  array in the host mesh must be non-NULL as well - animation"]
    #[doc = "  meshes may neither add or nor remove vertex components (if"]
    #[doc = "  a replacement array is NULL and the corresponding source"]
    #[doc = "  array is not, the source data is taken instead)"]
    pub mVertices: *mut aiVector3D,
    #[doc = " Replacement for aiMesh::mNormals."]
    pub mNormals: *mut aiVector3D,
    #[doc = " Replacement for aiMesh::mTangents."]
    pub mTangents: *mut aiVector3D,
    #[doc = " Replacement for aiMesh::mBitangents."]
    pub mBitangents: *mut aiVector3D,
    #[doc = " Replacement for aiMesh::mColors"]
    pub mColors: [*mut aiColor4D; 8usize],
    #[doc = " Replacement for aiMesh::mTextureCoords"]
    pub mTextureCoords: [*mut aiVector3D; 8usize],
    #[doc = " The number of vertices in the aiAnimMesh, and thus the length of all"]
    #[doc = " the member arrays."]
    #[doc = ""]
    #[doc = " This has always the same value as the mNumVertices property in the"]
    #[doc = " corresponding aiMesh. It is duplicated here merely to make the length"]
    #[doc = " of the member arrays accessible even if the aiMesh is not known, e.g."]
    #[doc = " from language bindings."]
    pub mNumVertices: ::std::os::raw::c_uint,
    #[doc = " Weight of the AnimMesh."]
    pub mWeight: f32,
}
#[test]
fn bindgen_test_layout_aiAnimMesh() {
    assert_eq!(
        ::std::mem::size_of::<aiAnimMesh>(),
        1200usize,
        concat!("Size of: ", stringify!(aiAnimMesh))
    );
    assert_eq!(
        ::std::mem::align_of::<aiAnimMesh>(),
        8usize,
        concat!("Alignment of ", stringify!(aiAnimMesh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mVertices as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mNormals as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mNormals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mTangents as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mTangents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mBitangents as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mBitangents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mColors as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mColors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mTextureCoords as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mTextureCoords)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mNumVertices as *const _ as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mNumVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimMesh>())).mWeight as *const _ as usize },
        1196usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimMesh),
            "::",
            stringify!(mWeight)
        )
    );
}
#[doc = " @brief A mesh represents a geometry or model with a single material."]
#[doc = ""]
#[doc = " It usually consists of a number of vertices and a series of primitives/faces"]
#[doc = " referencing the vertices. In addition there might be a series of bones, each"]
#[doc = " of them addressing a number of vertices with a certain weight. Vertex data"]
#[doc = " is presented in channels with each channel containing a single per-vertex"]
#[doc = " information such as a set of texture coords or a normal vector."]
#[doc = " If a data pointer is non-null, the corresponding data stream is present."]
#[doc = " From C++-programs you can also use the comfort functions Has*() to"]
#[doc = " test for the presence of various data streams."]
#[doc = ""]
#[doc = " A Mesh uses only a single material which is referenced by a material ID."]
#[doc = " @note The mPositions member is usually not optional. However, vertex positions"]
#[doc = " *could* be missing if the #AI_SCENE_FLAGS_INCOMPLETE flag is set in"]
#[doc = " @code"]
#[doc = " aiScene::mFlags"]
#[doc = " @endcode"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aiMesh {
    #[doc = " Bitwise combination of the members of the #aiPrimitiveType enum."]
    #[doc = " This specifies which types of primitives are present in the mesh."]
    #[doc = " The \"SortByPrimitiveType\"-Step can be used to make sure the"]
    #[doc = " output meshes consist of one primitive type each."]
    pub mPrimitiveTypes: ::std::os::raw::c_uint,
    #[doc = " The number of vertices in this mesh."]
    #[doc = " This is also the size of all of the per-vertex data arrays."]
    #[doc = " The maximum value for this member is #AI_MAX_VERTICES."]
    pub mNumVertices: ::std::os::raw::c_uint,
    #[doc = " The number of primitives (triangles, polygons, lines) in this  mesh."]
    #[doc = " This is also the size of the mFaces array."]
    #[doc = " The maximum value for this member is #AI_MAX_FACES."]
    pub mNumFaces: ::std::os::raw::c_uint,
    #[doc = " Vertex positions."]
    #[doc = " This array is always present in a mesh. The array is"]
    #[doc = " mNumVertices in size."]
    pub mVertices: *mut aiVector3D,
    #[doc = " Vertex normals."]
    #[doc = " The array contains normalized vectors, NULL if not present."]
    #[doc = " The array is mNumVertices in size. Normals are undefined for"]
    #[doc = " point and line primitives. A mesh consisting of points and"]
    #[doc = " lines only may not have normal vectors. Meshes with mixed"]
    #[doc = " primitive types (i.e. lines and triangles) may have normals,"]
    #[doc = " but the normals for vertices that are only referenced by"]
    #[doc = " point or line primitives are undefined and set to QNaN (WARN:"]
    #[doc = " qNaN compares to inequal to *everything*, even to qNaN itself."]
    #[doc = " Using code like this to check whether a field is qnan is:"]
    #[doc = " @code"]
    #[doc = " #define IS_QNAN(f) (f != f)"]
    #[doc = " @endcode"]
    #[doc = " still dangerous because even 1.f == 1.f could evaluate to false! ("]
    #[doc = " remember the subtleties of IEEE754 artithmetics). Use stuff like"]
    #[doc = " @c fpclassify instead."]
    #[doc = " @note Normal vectors computed by Assimp are always unit-length."]
    #[doc = " However, this needn't apply for normals that have been taken"]
    #[doc = "   directly from the model file."]
    pub mNormals: *mut aiVector3D,
    #[doc = " Vertex tangents."]
    #[doc = " The tangent of a vertex points in the direction of the positive"]
    #[doc = " X texture axis. The array contains normalized vectors, NULL if"]
    #[doc = " not present. The array is mNumVertices in size. A mesh consisting"]
    #[doc = " of points and lines only may not have normal vectors. Meshes with"]
    #[doc = " mixed primitive types (i.e. lines and triangles) may have"]
    #[doc = " normals, but the normals for vertices that are only referenced by"]
    #[doc = " point or line primitives are undefined and set to qNaN.  See"]
    #[doc = " the #mNormals member for a detailed discussion of qNaNs."]
    #[doc = " @note If the mesh contains tangents, it automatically also"]
    #[doc = " contains bitangents."]
    pub mTangents: *mut aiVector3D,
    #[doc = " Vertex bitangents."]
    #[doc = " The bitangent of a vertex points in the direction of the positive"]
    #[doc = " Y texture axis. The array contains normalized vectors, NULL if not"]
    #[doc = " present. The array is mNumVertices in size."]
    #[doc = " @note If the mesh contains tangents, it automatically also contains"]
    #[doc = " bitangents."]
    pub mBitangents: *mut aiVector3D,
    #[doc = " Vertex color sets."]
    #[doc = " A mesh may contain 0 to #AI_MAX_NUMBER_OF_COLOR_SETS vertex"]
    #[doc = " colors per vertex. NULL if not present. Each array is"]
    #[doc = " mNumVertices in size if present."]
    pub mColors: [*mut aiColor4D; 8usize],
    #[doc = " Vertex texture coords, also known as UV channels."]
    #[doc = " A mesh may contain 0 to AI_MAX_NUMBER_OF_TEXTURECOORDS per"]
    #[doc = " vertex. NULL if not present. The array is mNumVertices in size."]
    pub mTextureCoords: [*mut aiVector3D; 8usize],
    #[doc = " Specifies the number of components for a given UV channel."]
    #[doc = " Up to three channels are supported (UVW, for accessing volume"]
    #[doc = " or cube maps). If the value is 2 for a given channel n, the"]
    #[doc = " component p.z of mTextureCoords[n][p] is set to 0.0f."]
    #[doc = " If the value is 1 for a given channel, p.y is set to 0.0f, too."]
    #[doc = " @note 4D coords are not supported"]
    pub mNumUVComponents: [::std::os::raw::c_uint; 8usize],
    #[doc = " The faces the mesh is constructed from."]
    #[doc = " Each face refers to a number of vertices by their indices."]
    #[doc = " This array is always present in a mesh, its size is given"]
    #[doc = " in mNumFaces. If the #AI_SCENE_FLAGS_NON_VERBOSE_FORMAT"]
    #[doc = " is NOT set each face references an unique set of vertices."]
    pub mFaces: *mut aiFace,
    #[doc = " The number of bones this mesh contains."]
    #[doc = " Can be 0, in which case the mBones array is NULL."]
    pub mNumBones: ::std::os::raw::c_uint,
    #[doc = " The bones of this mesh."]
    #[doc = " A bone consists of a name by which it can be found in the"]
    #[doc = " frame hierarchy and a set of vertex weights."]
    pub mBones: *mut *mut aiBone,
    #[doc = " The material used by this mesh."]
    #[doc = " A mesh uses only a single material. If an imported model uses"]
    #[doc = " multiple materials, the import splits up the mesh. Use this value"]
    #[doc = " as index into the scene's material list."]
    pub mMaterialIndex: ::std::os::raw::c_uint,
    #[doc = " Name of the mesh. Meshes can be named, but this is not a"]
    #[doc = "  requirement and leaving this field empty is totally fine."]
    #[doc = "  There are mainly three uses for mesh names:"]
    #[doc = "   - some formats name nodes and meshes independently."]
    #[doc = "   - importers tend to split meshes up to meet the"]
    #[doc = "      one-material-per-mesh requirement. Assigning"]
    #[doc = "      the same (dummy) name to each of the result meshes"]
    #[doc = "      aids the caller at recovering the original mesh"]
    #[doc = "      partitioning."]
    #[doc = "   - Vertex animations refer to meshes by their names."]
    pub mName: aiString,
    #[doc = " The number of attachment meshes. Note! Currently only works with Collada loader."]
    pub mNumAnimMeshes: ::std::os::raw::c_uint,
    #[doc = " Attachment meshes for this mesh, for vertex-based animation."]
    #[doc = "  Attachment meshes carry replacement data for some of the"]
    #[doc = "  mesh'es vertex components (usually positions, normals)."]
    #[doc = "  Note! Currently only works with Collada loader."]
    pub mAnimMeshes: *mut *mut aiAnimMesh,
    #[doc = "  Method of morphing when animeshes are specified."]
    pub mMethod: ::std::os::raw::c_uint,
    pub mAABB: aiAABB,
}
#[test]
fn bindgen_test_layout_aiMesh() {
    assert_eq!(
        ::std::mem::size_of::<aiMesh>(),
        1312usize,
        concat!("Size of: ", stringify!(aiMesh))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMesh>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMesh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mPrimitiveTypes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mPrimitiveTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mNumVertices as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mNumVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mNumFaces as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mNumFaces)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mVertices as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mNormals as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mNormals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mTangents as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mTangents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mBitangents as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mBitangents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mColors as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mColors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mTextureCoords as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mTextureCoords)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mNumUVComponents as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mNumUVComponents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mFaces as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mFaces)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mNumBones as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mNumBones)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mBones as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mBones)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mMaterialIndex as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mMaterialIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mName as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mNumAnimMeshes as *const _ as usize },
        1264usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mNumAnimMeshes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mAnimMeshes as *const _ as usize },
        1272usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mAnimMeshes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mMethod as *const _ as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mMethod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMesh>())).mAABB as *const _ as usize },
        1284usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMesh),
            "::",
            stringify!(mAABB)
        )
    );
}
pub const aiLightSourceType_aiLightSource_UNDEFINED: aiLightSourceType = 0;
#[doc = "! A directional light source has a well-defined direction"]
#[doc = "! but is infinitely far away. That's quite a good"]
#[doc = "! approximation for sun light."]
pub const aiLightSourceType_aiLightSource_DIRECTIONAL: aiLightSourceType = 1;
#[doc = "! A point light source has a well-defined position"]
#[doc = "! in space but no direction - it emits light in all"]
#[doc = "! directions. A normal bulb is a point light."]
pub const aiLightSourceType_aiLightSource_POINT: aiLightSourceType = 2;
#[doc = "! A spot light source emits light in a specific"]
#[doc = "! angle. It has a position and a direction it is pointing to."]
#[doc = "! A good example for a spot light is a light spot in"]
#[doc = "! sport arenas."]
pub const aiLightSourceType_aiLightSource_SPOT: aiLightSourceType = 3;
#[doc = "! The generic light level of the world, including the bounces"]
#[doc = "! of all other light sources."]
#[doc = "! Typically, there's at most one ambient light in a scene."]
#[doc = "! This light type doesn't have a valid position, direction, or"]
#[doc = "! other properties, just a color."]
pub const aiLightSourceType_aiLightSource_AMBIENT: aiLightSourceType = 4;
#[doc = "! An area light is a rectangle with predefined size that uniformly"]
#[doc = "! emits light from one of its sides. The position is center of the"]
#[doc = "! rectangle and direction is its normal vector."]
pub const aiLightSourceType_aiLightSource_AREA: aiLightSourceType = 5;
pub const aiLightSourceType__aiLightSource_Force32Bit: aiLightSourceType = 2147483647;
#[doc = " Enumerates all supported types of light sources."]
pub type aiLightSourceType = ::std::os::raw::c_uint;
#[doc = " Helper structure to describe a light source."]
#[doc = ""]
#[doc = "  Assimp supports multiple sorts of light sources, including"]
#[doc = "  directional, point and spot lights. All of them are defined with just"]
#[doc = "  a single structure and distinguished by their parameters."]
#[doc = "  Note - some file formats (such as 3DS, ASE) export a \"target point\" -"]
#[doc = "  the point a spot light is looking at (it can even be animated). Assimp"]
#[doc = "  writes the target point as a subnode of a spotlights's main node,"]
#[doc = "  called \"<spotName>.Target\". However, this is just additional information"]
#[doc = "  then, the transformation tracks of the main node make the"]
#[doc = "  spot light already point in the right direction."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aiLight {
    #[doc = " The name of the light source."]
    #[doc = ""]
    #[doc = "  There must be a node in the scenegraph with the same name."]
    #[doc = "  This node specifies the position of the light in the scene"]
    #[doc = "  hierarchy and can be animated."]
    pub mName: aiString,
    #[doc = " The type of the light source."]
    #[doc = ""]
    #[doc = " aiLightSource_UNDEFINED is not a valid value for this member."]
    pub mType: aiLightSourceType,
    #[doc = " Position of the light source in space. Relative to the"]
    #[doc = "  transformation of the node corresponding to the light."]
    #[doc = ""]
    #[doc = "  The position is undefined for directional lights."]
    pub mPosition: aiVector3D,
    #[doc = " Direction of the light source in space. Relative to the"]
    #[doc = "  transformation of the node corresponding to the light."]
    #[doc = ""]
    #[doc = "  The direction is undefined for point lights. The vector"]
    #[doc = "  may be normalized, but it needn't."]
    pub mDirection: aiVector3D,
    #[doc = " Up direction of the light source in space. Relative to the"]
    #[doc = "  transformation of the node corresponding to the light."]
    #[doc = ""]
    #[doc = "  The direction is undefined for point lights. The vector"]
    #[doc = "  may be normalized, but it needn't."]
    pub mUp: aiVector3D,
    #[doc = " Constant light attenuation factor."]
    #[doc = ""]
    #[doc = "  The intensity of the light source at a given distance 'd' from"]
    #[doc = "  the light's position is"]
    #[doc = "  @code"]
    #[doc = "  Atten = 1/( att0 + att1 * d + att2 * d*d)"]
    #[doc = "  @endcode"]
    #[doc = "  This member corresponds to the att0 variable in the equation."]
    #[doc = "  Naturally undefined for directional lights."]
    pub mAttenuationConstant: f32,
    #[doc = " Linear light attenuation factor."]
    #[doc = ""]
    #[doc = "  The intensity of the light source at a given distance 'd' from"]
    #[doc = "  the light's position is"]
    #[doc = "  @code"]
    #[doc = "  Atten = 1/( att0 + att1 * d + att2 * d*d)"]
    #[doc = "  @endcode"]
    #[doc = "  This member corresponds to the att1 variable in the equation."]
    #[doc = "  Naturally undefined for directional lights."]
    pub mAttenuationLinear: f32,
    #[doc = " Quadratic light attenuation factor."]
    #[doc = ""]
    #[doc = "  The intensity of the light source at a given distance 'd' from"]
    #[doc = "  the light's position is"]
    #[doc = "  @code"]
    #[doc = "  Atten = 1/( att0 + att1 * d + att2 * d*d)"]
    #[doc = "  @endcode"]
    #[doc = "  This member corresponds to the att2 variable in the equation."]
    #[doc = "  Naturally undefined for directional lights."]
    pub mAttenuationQuadratic: f32,
    #[doc = " Diffuse color of the light source"]
    #[doc = ""]
    #[doc = "  The diffuse light color is multiplied with the diffuse"]
    #[doc = "  material color to obtain the final color that contributes"]
    #[doc = "  to the diffuse shading term."]
    pub mColorDiffuse: aiColor3D,
    #[doc = " Specular color of the light source"]
    #[doc = ""]
    #[doc = "  The specular light color is multiplied with the specular"]
    #[doc = "  material color to obtain the final color that contributes"]
    #[doc = "  to the specular shading term."]
    pub mColorSpecular: aiColor3D,
    #[doc = " Ambient color of the light source"]
    #[doc = ""]
    #[doc = "  The ambient light color is multiplied with the ambient"]
    #[doc = "  material color to obtain the final color that contributes"]
    #[doc = "  to the ambient shading term. Most renderers will ignore"]
    #[doc = "  this value it, is just a remaining of the fixed-function pipeline"]
    #[doc = "  that is still supported by quite many file formats."]
    pub mColorAmbient: aiColor3D,
    #[doc = " Inner angle of a spot light's light cone."]
    #[doc = ""]
    #[doc = "  The spot light has maximum influence on objects inside this"]
    #[doc = "  angle. The angle is given in radians. It is 2PI for point"]
    #[doc = "  lights and undefined for directional lights."]
    pub mAngleInnerCone: f32,
    #[doc = " Outer angle of a spot light's light cone."]
    #[doc = ""]
    #[doc = "  The spot light does not affect objects outside this angle."]
    #[doc = "  The angle is given in radians. It is 2PI for point lights and"]
    #[doc = "  undefined for directional lights. The outer angle must be"]
    #[doc = "  greater than or equal to the inner angle."]
    #[doc = "  It is assumed that the application uses a smooth"]
    #[doc = "  interpolation between the inner and the outer cone of the"]
    #[doc = "  spot light."]
    pub mAngleOuterCone: f32,
    #[doc = " Size of area light source."]
    pub mSize: aiVector2D,
}
#[test]
fn bindgen_test_layout_aiLight() {
    assert_eq!(
        ::std::mem::size_of::<aiLight>(),
        1132usize,
        concat!("Size of: ", stringify!(aiLight))
    );
    assert_eq!(
        ::std::mem::align_of::<aiLight>(),
        4usize,
        concat!("Alignment of ", stringify!(aiLight))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mType as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mPosition as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mDirection as *const _ as usize },
        1044usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mDirection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mUp as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mUp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mAttenuationConstant as *const _ as usize },
        1068usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mAttenuationConstant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mAttenuationLinear as *const _ as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mAttenuationLinear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mAttenuationQuadratic as *const _ as usize },
        1076usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mAttenuationQuadratic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mColorDiffuse as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mColorDiffuse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mColorSpecular as *const _ as usize },
        1092usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mColorSpecular)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mColorAmbient as *const _ as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mColorAmbient)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mAngleInnerCone as *const _ as usize },
        1116usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mAngleInnerCone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mAngleOuterCone as *const _ as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mAngleOuterCone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiLight>())).mSize as *const _ as usize },
        1124usize,
        concat!(
            "Offset of field: ",
            stringify!(aiLight),
            "::",
            stringify!(mSize)
        )
    );
}
#[doc = " Helper structure to describe a virtual camera."]
#[doc = ""]
#[doc = " Cameras have a representation in the node graph and can be animated."]
#[doc = " An important aspect is that the camera itself is also part of the"]
#[doc = " scene-graph. This means, any values such as the look-at vector are not"]
#[doc = " *absolute*, they're <b>relative</b> to the coordinate system defined"]
#[doc = " by the node which corresponds to the camera. This allows for camera"]
#[doc = " animations. For static cameras parameters like the 'look-at' or 'up' vectors"]
#[doc = " are usually specified directly in aiCamera, but beware, they could also"]
#[doc = " be encoded in the node transformation. The following (pseudo)code sample"]
#[doc = " shows how to do it: <br><br>"]
#[doc = " @code"]
#[doc = " // Get the camera matrix for a camera at a specific time"]
#[doc = " // if the node hierarchy for the camera does not contain"]
#[doc = " // at least one animated node this is a static computation"]
#[doc = " get-camera-matrix (node sceneRoot, camera cam) : matrix"]
#[doc = " {"]
#[doc = "    node   cnd = find-node-for-camera(cam)"]
#[doc = "    matrix cmt = identity()"]
#[doc = ""]
#[doc = "    // as usual - get the absolute camera transformation for this frame"]
#[doc = "    for each node nd in hierarchy from sceneRoot to cnd"]
#[doc = "      matrix cur"]
#[doc = "      if (is-animated(nd))"]
#[doc = "         cur = eval-animation(nd)"]
#[doc = "      else cur = nd->mTransformation;"]
#[doc = "      cmt = mult-matrices( cmt, cur )"]
#[doc = "    end for"]
#[doc = ""]
#[doc = "    // now multiply with the camera's own local transform"]
#[doc = "    cam = mult-matrices (cam, get-camera-matrix(cmt) )"]
#[doc = " }"]
#[doc = " @endcode"]
#[doc = ""]
#[doc = " @note some file formats (such as 3DS, ASE) export a \"target point\" -"]
#[doc = " the point the camera is looking at (it can even be animated). Assimp"]
#[doc = " writes the target point as a subnode of the camera's main node,"]
#[doc = " called \"<camName>.Target\". However this is just additional information"]
#[doc = " then the transformation tracks of the camera main node make the"]
#[doc = " camera already look in the right direction."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aiCamera {
    #[doc = " The name of the camera."]
    #[doc = ""]
    #[doc = "  There must be a node in the scenegraph with the same name."]
    #[doc = "  This node specifies the position of the camera in the scene"]
    #[doc = "  hierarchy and can be animated."]
    pub mName: aiString,
    #[doc = " Position of the camera relative to the coordinate space"]
    #[doc = "  defined by the corresponding node."]
    #[doc = ""]
    #[doc = "  The default value is 0|0|0."]
    pub mPosition: aiVector3D,
    #[doc = " 'Up' - vector of the camera coordinate system relative to"]
    #[doc = "  the coordinate space defined by the corresponding node."]
    #[doc = ""]
    #[doc = "  The 'right' vector of the camera coordinate system is"]
    #[doc = "  the cross product of  the up and lookAt vectors."]
    #[doc = "  The default value is 0|1|0. The vector"]
    #[doc = "  may be normalized, but it needn't."]
    pub mUp: aiVector3D,
    #[doc = " 'LookAt' - vector of the camera coordinate system relative to"]
    #[doc = "  the coordinate space defined by the corresponding node."]
    #[doc = ""]
    #[doc = "  This is the viewing direction of the user."]
    #[doc = "  The default value is 0|0|1. The vector"]
    #[doc = "  may be normalized, but it needn't."]
    pub mLookAt: aiVector3D,
    #[doc = " Half horizontal field of view angle, in radians."]
    #[doc = ""]
    #[doc = "  The field of view angle is the angle between the center"]
    #[doc = "  line of the screen and the left or right border."]
    #[doc = "  The default value is 1/4PI."]
    pub mHorizontalFOV: f32,
    #[doc = " Distance of the near clipping plane from the camera."]
    #[doc = ""]
    #[doc = " The value may not be 0.f (for arithmetic reasons to prevent"]
    #[doc = " a division through zero). The default value is 0.1f."]
    pub mClipPlaneNear: f32,
    #[doc = " Distance of the far clipping plane from the camera."]
    #[doc = ""]
    #[doc = " The far clipping plane must, of course, be further away than the"]
    #[doc = " near clipping plane. The default value is 1000.f. The ratio"]
    #[doc = " between the near and the far plane should not be too"]
    #[doc = " large (between 1000-10000 should be ok) to avoid floating-point"]
    #[doc = " inaccuracies which could lead to z-fighting."]
    pub mClipPlaneFar: f32,
    #[doc = " Screen aspect ratio."]
    #[doc = ""]
    #[doc = " This is the ration between the width and the height of the"]
    #[doc = " screen. Typical values are 4/3, 1/2 or 1/1. This value is"]
    #[doc = " 0 if the aspect ratio is not defined in the source file."]
    #[doc = " 0 is also the default value."]
    pub mAspect: f32,
}
#[test]
fn bindgen_test_layout_aiCamera() {
    assert_eq!(
        ::std::mem::size_of::<aiCamera>(),
        1080usize,
        concat!("Size of: ", stringify!(aiCamera))
    );
    assert_eq!(
        ::std::mem::align_of::<aiCamera>(),
        4usize,
        concat!("Alignment of ", stringify!(aiCamera))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mPosition as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mUp as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mUp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mLookAt as *const _ as usize },
        1052usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mLookAt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mHorizontalFOV as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mHorizontalFOV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mClipPlaneNear as *const _ as usize },
        1068usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mClipPlaneNear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mClipPlaneFar as *const _ as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mClipPlaneFar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiCamera>())).mAspect as *const _ as usize },
        1076usize,
        concat!(
            "Offset of field: ",
            stringify!(aiCamera),
            "::",
            stringify!(mAspect)
        )
    );
}
#[doc = " Dummy value."]
#[doc = ""]
#[doc = "  No texture, but the value to be used as 'texture semantic'"]
#[doc = "  (#aiMaterialProperty::mSemantic) for all material properties"]
#[doc = "  *not* related to textures."]
pub const aiTextureType_aiTextureType_NONE: aiTextureType = 0;
#[doc = " The texture is combined with the result of the diffuse"]
#[doc = "  lighting equation."]
pub const aiTextureType_aiTextureType_DIFFUSE: aiTextureType = 1;
#[doc = " The texture is combined with the result of the specular"]
#[doc = "  lighting equation."]
pub const aiTextureType_aiTextureType_SPECULAR: aiTextureType = 2;
#[doc = " The texture is combined with the result of the ambient"]
#[doc = "  lighting equation."]
pub const aiTextureType_aiTextureType_AMBIENT: aiTextureType = 3;
#[doc = " The texture is added to the result of the lighting"]
#[doc = "  calculation. It isn't influenced by incoming light."]
pub const aiTextureType_aiTextureType_EMISSIVE: aiTextureType = 4;
#[doc = " The texture is a height map."]
#[doc = ""]
#[doc = "  By convention, higher gray-scale values stand for"]
#[doc = "  higher elevations from the base height."]
pub const aiTextureType_aiTextureType_HEIGHT: aiTextureType = 5;
#[doc = " The texture is a (tangent space) normal-map."]
#[doc = ""]
#[doc = "  Again, there are several conventions for tangent-space"]
#[doc = "  normal maps. Assimp does (intentionally) not"]
#[doc = "  distinguish here."]
pub const aiTextureType_aiTextureType_NORMALS: aiTextureType = 6;
#[doc = " The texture defines the glossiness of the material."]
#[doc = ""]
#[doc = "  The glossiness is in fact the exponent of the specular"]
#[doc = "  (phong) lighting equation. Usually there is a conversion"]
#[doc = "  function defined to map the linear color values in the"]
#[doc = "  texture to a suitable exponent. Have fun."]
pub const aiTextureType_aiTextureType_SHININESS: aiTextureType = 7;
#[doc = " The texture defines per-pixel opacity."]
#[doc = ""]
#[doc = "  Usually 'white' means opaque and 'black' means"]
#[doc = "  'transparency'. Or quite the opposite. Have fun."]
pub const aiTextureType_aiTextureType_OPACITY: aiTextureType = 8;
#[doc = " Displacement texture"]
#[doc = ""]
#[doc = "  The exact purpose and format is application-dependent."]
#[doc = "  Higher color values stand for higher vertex displacements."]
pub const aiTextureType_aiTextureType_DISPLACEMENT: aiTextureType = 9;
#[doc = " Lightmap texture (aka Ambient Occlusion)"]
#[doc = ""]
#[doc = "  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are"]
#[doc = "  covered by this material property. The texture contains a"]
#[doc = "  scaling value for the final color value of a pixel. Its"]
#[doc = "  intensity is not affected by incoming light."]
pub const aiTextureType_aiTextureType_LIGHTMAP: aiTextureType = 10;
#[doc = " Reflection texture"]
#[doc = ""]
#[doc = " Contains the color of a perfect mirror reflection."]
#[doc = " Rarely used, almost never for real-time applications."]
pub const aiTextureType_aiTextureType_REFLECTION: aiTextureType = 11;
#[doc = " PBR Materials"]
#[doc = " PBR definitions from maya and other modelling packages now use this standard."]
#[doc = " This was originally introduced around 2012."]
#[doc = " Support for this is in game engines like Godot, Unreal or Unity3D."]
#[doc = " Modelling packages which use this are very common now."]
pub const aiTextureType_aiTextureType_BASE_COLOR: aiTextureType = 12;
#[doc = " PBR Materials"]
#[doc = " PBR definitions from maya and other modelling packages now use this standard."]
#[doc = " This was originally introduced around 2012."]
#[doc = " Support for this is in game engines like Godot, Unreal or Unity3D."]
#[doc = " Modelling packages which use this are very common now."]
pub const aiTextureType_aiTextureType_NORMAL_CAMERA: aiTextureType = 13;
#[doc = " PBR Materials"]
#[doc = " PBR definitions from maya and other modelling packages now use this standard."]
#[doc = " This was originally introduced around 2012."]
#[doc = " Support for this is in game engines like Godot, Unreal or Unity3D."]
#[doc = " Modelling packages which use this are very common now."]
pub const aiTextureType_aiTextureType_EMISSION_COLOR: aiTextureType = 14;
#[doc = " PBR Materials"]
#[doc = " PBR definitions from maya and other modelling packages now use this standard."]
#[doc = " This was originally introduced around 2012."]
#[doc = " Support for this is in game engines like Godot, Unreal or Unity3D."]
#[doc = " Modelling packages which use this are very common now."]
pub const aiTextureType_aiTextureType_METALNESS: aiTextureType = 15;
#[doc = " PBR Materials"]
#[doc = " PBR definitions from maya and other modelling packages now use this standard."]
#[doc = " This was originally introduced around 2012."]
#[doc = " Support for this is in game engines like Godot, Unreal or Unity3D."]
#[doc = " Modelling packages which use this are very common now."]
pub const aiTextureType_aiTextureType_DIFFUSE_ROUGHNESS: aiTextureType = 16;
#[doc = " PBR Materials"]
#[doc = " PBR definitions from maya and other modelling packages now use this standard."]
#[doc = " This was originally introduced around 2012."]
#[doc = " Support for this is in game engines like Godot, Unreal or Unity3D."]
#[doc = " Modelling packages which use this are very common now."]
pub const aiTextureType_aiTextureType_AMBIENT_OCCLUSION: aiTextureType = 17;
#[doc = " Unknown texture"]
#[doc = ""]
#[doc = "  A texture reference that does not match any of the definitions"]
#[doc = "  above is considered to be 'unknown'. It is still imported,"]
#[doc = "  but is excluded from any further post-processing."]
pub const aiTextureType_aiTextureType_UNKNOWN: aiTextureType = 18;
pub const aiTextureType__aiTextureType_Force32Bit: aiTextureType = 2147483647;
#[doc = " @brief Defines the purpose of a texture"]
#[doc = ""]
#[doc = "  This is a very difficult topic. Different 3D packages support different"]
#[doc = "  kinds of textures. For very common texture types, such as bumpmaps, the"]
#[doc = "  rendering results depend on implementation details in the rendering"]
#[doc = "  pipelines of these applications. Assimp loads all texture references from"]
#[doc = "  the model file and tries to determine which of the predefined texture"]
#[doc = "  types below is the best choice to match the original use of the texture"]
#[doc = "  as closely as possible.<br>"]
#[doc = ""]
#[doc = "  In content pipelines you'll usually define how textures have to be handled,"]
#[doc = "  and the artists working on models have to conform to this specification,"]
#[doc = "  regardless which 3D tool they're using."]
pub type aiTextureType = ::std::os::raw::c_uint;
#[doc = " Array of single-precision (32 Bit) floats"]
#[doc = ""]
#[doc = "  It is possible to use aiGetMaterialInteger[Array]() (or the C++-API"]
#[doc = "  aiMaterial::Get()) to query properties stored in floating-point format."]
#[doc = "  The material system performs the type conversion automatically."]
pub const aiPropertyTypeInfo_aiPTI_Float: aiPropertyTypeInfo = 1;
#[doc = " Array of double-precision (64 Bit) floats"]
#[doc = ""]
#[doc = "  It is possible to use aiGetMaterialInteger[Array]() (or the C++-API"]
#[doc = "  aiMaterial::Get()) to query properties stored in floating-point format."]
#[doc = "  The material system performs the type conversion automatically."]
pub const aiPropertyTypeInfo_aiPTI_Double: aiPropertyTypeInfo = 2;
#[doc = " The material property is an aiString."]
#[doc = ""]
#[doc = "  Arrays of strings aren't possible, aiGetMaterialString() (or the"]
#[doc = "  C++-API aiMaterial::Get()) *must* be used to query a string property."]
pub const aiPropertyTypeInfo_aiPTI_String: aiPropertyTypeInfo = 3;
#[doc = " Array of (32 Bit) integers"]
#[doc = ""]
#[doc = "  It is possible to use aiGetMaterialFloat[Array]() (or the C++-API"]
#[doc = "  aiMaterial::Get()) to query properties stored in integer format."]
#[doc = "  The material system performs the type conversion automatically."]
pub const aiPropertyTypeInfo_aiPTI_Integer: aiPropertyTypeInfo = 4;
#[doc = " Simple binary buffer, content undefined. Not convertible to anything."]
pub const aiPropertyTypeInfo_aiPTI_Buffer: aiPropertyTypeInfo = 5;
pub const aiPropertyTypeInfo__aiPTI_Force32Bit: aiPropertyTypeInfo = 2147483647;
#[doc = " @brief A very primitive RTTI system for the contents of material"]
#[doc = "  properties."]
pub type aiPropertyTypeInfo = ::std::os::raw::c_uint;
#[doc = " @brief Data structure for a single material property"]
#[doc = ""]
#[doc = "  As an user, you'll probably never need to deal with this data structure."]
#[doc = "  Just use the provided aiGetMaterialXXX() or aiMaterial::Get() family"]
#[doc = "  of functions to query material properties easily. Processing them"]
#[doc = "  manually is faster, but it is not the recommended way. It isn't worth"]
#[doc = "  the effort. <br>"]
#[doc = "  Material property names follow a simple scheme:"]
#[doc = "  @code"]
#[doc = "    $<name>"]
#[doc = "    ?<name>"]
#[doc = "       A public property, there must be corresponding AI_MATKEY_XXX define"]
#[doc = "       2nd: Public, but ignored by the #aiProcess_RemoveRedundantMaterials"]
#[doc = "       post-processing step."]
#[doc = "    ~<name>"]
#[doc = "       A temporary property for internal use."]
#[doc = "  @endcode"]
#[doc = "  @see aiMaterial"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aiMaterialProperty {
    #[doc = " Specifies the name of the property (key)"]
    #[doc = "  Keys are generally case insensitive."]
    pub mKey: aiString,
    #[doc = " Textures: Specifies their exact usage semantic."]
    #[doc = " For non-texture properties, this member is always 0"]
    #[doc = " (or, better-said, #aiTextureType_NONE)."]
    pub mSemantic: ::std::os::raw::c_uint,
    #[doc = " Textures: Specifies the index of the texture."]
    #[doc = "  For non-texture properties, this member is always 0."]
    pub mIndex: ::std::os::raw::c_uint,
    #[doc = " Size of the buffer mData is pointing to, in bytes."]
    #[doc = "  This value may not be 0."]
    pub mDataLength: ::std::os::raw::c_uint,
    #[doc = " Type information for the property."]
    #[doc = ""]
    #[doc = " Defines the data layout inside the data buffer. This is used"]
    #[doc = " by the library internally to perform debug checks and to"]
    #[doc = " utilize proper type conversions."]
    #[doc = " (It's probably a hacky solution, but it works.)"]
    pub mType: aiPropertyTypeInfo,
    #[doc = " Binary buffer to hold the property's value."]
    #[doc = " The size of the buffer is always mDataLength."]
    pub mData: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_aiMaterialProperty() {
    assert_eq!(
        ::std::mem::size_of::<aiMaterialProperty>(),
        1056usize,
        concat!("Size of: ", stringify!(aiMaterialProperty))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMaterialProperty>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMaterialProperty))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterialProperty>())).mKey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterialProperty),
            "::",
            stringify!(mKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterialProperty>())).mSemantic as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterialProperty),
            "::",
            stringify!(mSemantic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterialProperty>())).mIndex as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterialProperty),
            "::",
            stringify!(mIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterialProperty>())).mDataLength as *const _ as usize },
        1036usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterialProperty),
            "::",
            stringify!(mDataLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterialProperty>())).mType as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterialProperty),
            "::",
            stringify!(mType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterialProperty>())).mData as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterialProperty),
            "::",
            stringify!(mData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiMaterial {
    #[doc = " List of all material properties loaded."]
    pub mProperties: *mut *mut aiMaterialProperty,
    #[doc = " Number of properties in the data base"]
    pub mNumProperties: ::std::os::raw::c_uint,
    #[doc = " Storage allocated"]
    pub mNumAllocated: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_aiMaterial() {
    assert_eq!(
        ::std::mem::size_of::<aiMaterial>(),
        16usize,
        concat!("Size of: ", stringify!(aiMaterial))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMaterial>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMaterial))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterial>())).mProperties as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterial),
            "::",
            stringify!(mProperties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterial>())).mNumProperties as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterial),
            "::",
            stringify!(mNumProperties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMaterial>())).mNumAllocated as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMaterial),
            "::",
            stringify!(mNumAllocated)
        )
    );
}
#[doc = " A time-value pair specifying a certain 3D vector for the given time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiVectorKey {
    #[doc = " The time of this key"]
    pub mTime: f64,
    #[doc = " The value of this key"]
    pub mValue: aiVector3D,
}
#[test]
fn bindgen_test_layout_aiVectorKey() {
    assert_eq!(
        ::std::mem::size_of::<aiVectorKey>(),
        24usize,
        concat!("Size of: ", stringify!(aiVectorKey))
    );
    assert_eq!(
        ::std::mem::align_of::<aiVectorKey>(),
        8usize,
        concat!("Alignment of ", stringify!(aiVectorKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVectorKey>())).mTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVectorKey),
            "::",
            stringify!(mTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiVectorKey>())).mValue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiVectorKey),
            "::",
            stringify!(mValue)
        )
    );
}
#[doc = " A time-value pair specifying a rotation for the given time."]
#[doc = "  Rotations are expressed with quaternions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiQuatKey {
    #[doc = " The time of this key"]
    pub mTime: f64,
    #[doc = " The value of this key"]
    pub mValue: aiQuaternion,
}
#[test]
fn bindgen_test_layout_aiQuatKey() {
    assert_eq!(
        ::std::mem::size_of::<aiQuatKey>(),
        24usize,
        concat!("Size of: ", stringify!(aiQuatKey))
    );
    assert_eq!(
        ::std::mem::align_of::<aiQuatKey>(),
        8usize,
        concat!("Alignment of ", stringify!(aiQuatKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiQuatKey>())).mTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiQuatKey),
            "::",
            stringify!(mTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiQuatKey>())).mValue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiQuatKey),
            "::",
            stringify!(mValue)
        )
    );
}
#[doc = " Binds a anim-mesh to a specific point in time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiMeshKey {
    #[doc = " The time of this key"]
    pub mTime: f64,
    #[doc = " Index into the aiMesh::mAnimMeshes array of the"]
    #[doc = "  mesh corresponding to the #aiMeshAnim hosting this"]
    #[doc = "  key frame. The referenced anim mesh is evaluated"]
    #[doc = "  according to the rules defined in the docs for #aiAnimMesh."]
    pub mValue: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_aiMeshKey() {
    assert_eq!(
        ::std::mem::size_of::<aiMeshKey>(),
        16usize,
        concat!("Size of: ", stringify!(aiMeshKey))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMeshKey>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMeshKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshKey>())).mTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshKey),
            "::",
            stringify!(mTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshKey>())).mValue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshKey),
            "::",
            stringify!(mValue)
        )
    );
}
#[doc = " Binds a morph anim mesh to a specific point in time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiMeshMorphKey {
    #[doc = " The time of this key"]
    pub mTime: f64,
    #[doc = " The values and weights at the time of this key"]
    pub mValues: *mut ::std::os::raw::c_uint,
    pub mWeights: *mut f64,
    #[doc = " The number of values and weights"]
    pub mNumValuesAndWeights: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_aiMeshMorphKey() {
    assert_eq!(
        ::std::mem::size_of::<aiMeshMorphKey>(),
        32usize,
        concat!("Size of: ", stringify!(aiMeshMorphKey))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMeshMorphKey>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMeshMorphKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshMorphKey>())).mTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshMorphKey),
            "::",
            stringify!(mTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshMorphKey>())).mValues as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshMorphKey),
            "::",
            stringify!(mValues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshMorphKey>())).mWeights as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshMorphKey),
            "::",
            stringify!(mWeights)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<aiMeshMorphKey>())).mNumValuesAndWeights as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshMorphKey),
            "::",
            stringify!(mNumValuesAndWeights)
        )
    );
}
#[doc = " The value from the default node transformation is taken"]
pub const aiAnimBehaviour_aiAnimBehaviour_DEFAULT: aiAnimBehaviour = 0;
#[doc = " The nearest key value is used without interpolation"]
pub const aiAnimBehaviour_aiAnimBehaviour_CONSTANT: aiAnimBehaviour = 1;
#[doc = " The value of the nearest two keys is linearly"]
#[doc = "  extrapolated for the current time value."]
pub const aiAnimBehaviour_aiAnimBehaviour_LINEAR: aiAnimBehaviour = 2;
#[doc = " The animation is repeated."]
#[doc = ""]
#[doc = "  If the animation key go from n to m and the current"]
#[doc = "  time is t, use the value at (t-n) % (|m-n|)."]
pub const aiAnimBehaviour_aiAnimBehaviour_REPEAT: aiAnimBehaviour = 3;
pub const aiAnimBehaviour__aiAnimBehaviour_Force32Bit: aiAnimBehaviour = 2147483647;
#[doc = " Defines how an animation channel behaves outside the defined time"]
#[doc = "  range. This corresponds to aiNodeAnim::mPreState and"]
#[doc = "  aiNodeAnim::mPostState."]
pub type aiAnimBehaviour = ::std::os::raw::c_uint;
#[doc = " Describes the animation of a single node. The name specifies the"]
#[doc = "  bone/node which is affected by this animation channel. The keyframes"]
#[doc = "  are given in three separate series of values, one each for position,"]
#[doc = "  rotation and scaling. The transformation matrix computed from these"]
#[doc = "  values replaces the node's original transformation matrix at a"]
#[doc = "  specific time."]
#[doc = "  This means all keys are absolute and not relative to the bone default pose."]
#[doc = "  The order in which the transformations are applied is"]
#[doc = "  - as usual - scaling, rotation, translation."]
#[doc = ""]
#[doc = "  @note All keys are returned in their correct, chronological order."]
#[doc = "  Duplicate keys don't pass the validation step. Most likely there"]
#[doc = "  will be no negative time values, but they are not forbidden also ( so"]
#[doc = "  implementations need to cope with them! )"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aiNodeAnim {
    #[doc = " The name of the node affected by this animation. The node"]
    #[doc = "  must exist and it must be unique."]
    pub mNodeName: aiString,
    #[doc = " The number of position keys"]
    pub mNumPositionKeys: ::std::os::raw::c_uint,
    #[doc = " The position keys of this animation channel. Positions are"]
    #[doc = " specified as 3D vector. The array is mNumPositionKeys in size."]
    #[doc = ""]
    #[doc = " If there are position keys, there will also be at least one"]
    #[doc = " scaling and one rotation key."]
    pub mPositionKeys: *mut aiVectorKey,
    #[doc = " The number of rotation keys"]
    pub mNumRotationKeys: ::std::os::raw::c_uint,
    #[doc = " The rotation keys of this animation channel. Rotations are"]
    #[doc = "  given as quaternions,  which are 4D vectors. The array is"]
    #[doc = "  mNumRotationKeys in size."]
    #[doc = ""]
    #[doc = " If there are rotation keys, there will also be at least one"]
    #[doc = " scaling and one position key."]
    pub mRotationKeys: *mut aiQuatKey,
    #[doc = " The number of scaling keys"]
    pub mNumScalingKeys: ::std::os::raw::c_uint,
    #[doc = " The scaling keys of this animation channel. Scalings are"]
    #[doc = "  specified as 3D vector. The array is mNumScalingKeys in size."]
    #[doc = ""]
    #[doc = " If there are scaling keys, there will also be at least one"]
    #[doc = " position and one rotation key."]
    pub mScalingKeys: *mut aiVectorKey,
    #[doc = " Defines how the animation behaves before the first"]
    #[doc = "  key is encountered."]
    #[doc = ""]
    #[doc = "  The default value is aiAnimBehaviour_DEFAULT (the original"]
    #[doc = "  transformation matrix of the affected node is used)."]
    pub mPreState: aiAnimBehaviour,
    #[doc = " Defines how the animation behaves after the last"]
    #[doc = "  key was processed."]
    #[doc = ""]
    #[doc = "  The default value is aiAnimBehaviour_DEFAULT (the original"]
    #[doc = "  transformation matrix of the affected node is taken)."]
    pub mPostState: aiAnimBehaviour,
}
#[test]
fn bindgen_test_layout_aiNodeAnim() {
    assert_eq!(
        ::std::mem::size_of::<aiNodeAnim>(),
        1080usize,
        concat!("Size of: ", stringify!(aiNodeAnim))
    );
    assert_eq!(
        ::std::mem::align_of::<aiNodeAnim>(),
        8usize,
        concat!("Alignment of ", stringify!(aiNodeAnim))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mNodeName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mNodeName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mNumPositionKeys as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mNumPositionKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mPositionKeys as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mPositionKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mNumRotationKeys as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mNumRotationKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mRotationKeys as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mRotationKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mNumScalingKeys as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mNumScalingKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mScalingKeys as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mScalingKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mPreState as *const _ as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mPreState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNodeAnim>())).mPostState as *const _ as usize },
        1076usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNodeAnim),
            "::",
            stringify!(mPostState)
        )
    );
}
#[doc = " Describes vertex-based animations for a single mesh or a group of"]
#[doc = "  meshes. Meshes carry the animation data for each frame in their"]
#[doc = "  aiMesh::mAnimMeshes array. The purpose of aiMeshAnim is to"]
#[doc = "  define keyframes linking each mesh attachment to a particular"]
#[doc = "  point in time."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aiMeshAnim {
    #[doc = " Name of the mesh to be animated. An empty string is not allowed,"]
    #[doc = "  animated meshes need to be named (not necessarily uniquely,"]
    #[doc = "  the name can basically serve as wild-card to select a group"]
    #[doc = "  of meshes with similar animation setup)"]
    pub mName: aiString,
    #[doc = " Size of the #mKeys array. Must be 1, at least."]
    pub mNumKeys: ::std::os::raw::c_uint,
    #[doc = " Key frames of the animation. May not be NULL."]
    pub mKeys: *mut aiMeshKey,
}
#[test]
fn bindgen_test_layout_aiMeshAnim() {
    assert_eq!(
        ::std::mem::size_of::<aiMeshAnim>(),
        1040usize,
        concat!("Size of: ", stringify!(aiMeshAnim))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMeshAnim>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMeshAnim))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshAnim>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshAnim),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshAnim>())).mNumKeys as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshAnim),
            "::",
            stringify!(mNumKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshAnim>())).mKeys as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshAnim),
            "::",
            stringify!(mKeys)
        )
    );
}
#[doc = " Describes a morphing animation of a given mesh."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aiMeshMorphAnim {
    #[doc = " Name of the mesh to be animated. An empty string is not allowed,"]
    #[doc = "  animated meshes need to be named (not necessarily uniquely,"]
    #[doc = "  the name can basically serve as wildcard to select a group"]
    #[doc = "  of meshes with similar animation setup)"]
    pub mName: aiString,
    #[doc = " Size of the #mKeys array. Must be 1, at least."]
    pub mNumKeys: ::std::os::raw::c_uint,
    #[doc = " Key frames of the animation. May not be NULL."]
    pub mKeys: *mut aiMeshMorphKey,
}
#[test]
fn bindgen_test_layout_aiMeshMorphAnim() {
    assert_eq!(
        ::std::mem::size_of::<aiMeshMorphAnim>(),
        1040usize,
        concat!("Size of: ", stringify!(aiMeshMorphAnim))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMeshMorphAnim>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMeshMorphAnim))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshMorphAnim>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshMorphAnim),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshMorphAnim>())).mNumKeys as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshMorphAnim),
            "::",
            stringify!(mNumKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMeshMorphAnim>())).mKeys as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMeshMorphAnim),
            "::",
            stringify!(mKeys)
        )
    );
}
#[doc = " An animation consists of key-frame data for a number of nodes. For"]
#[doc = "  each node affected by the animation a separate series of data is given."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aiAnimation {
    #[doc = " The name of the animation. If the modeling package this data was"]
    #[doc = "  exported from does support only a single animation channel, this"]
    #[doc = "  name is usually empty (length is zero)."]
    pub mName: aiString,
    #[doc = " Duration of the animation in ticks."]
    pub mDuration: f64,
    #[doc = " Ticks per second. 0 if not specified in the imported file"]
    pub mTicksPerSecond: f64,
    #[doc = " The number of bone animation channels. Each channel affects"]
    #[doc = "  a single node."]
    pub mNumChannels: ::std::os::raw::c_uint,
    #[doc = " The node animation channels. Each channel affects a single node."]
    #[doc = "  The array is mNumChannels in size."]
    pub mChannels: *mut *mut aiNodeAnim,
    #[doc = " The number of mesh animation channels. Each channel affects"]
    #[doc = "  a single mesh and defines vertex-based animation."]
    pub mNumMeshChannels: ::std::os::raw::c_uint,
    #[doc = " The mesh animation channels. Each channel affects a single mesh."]
    #[doc = "  The array is mNumMeshChannels in size."]
    pub mMeshChannels: *mut *mut aiMeshAnim,
    #[doc = " The number of mesh animation channels. Each channel affects"]
    #[doc = "  a single mesh and defines morphing animation."]
    pub mNumMorphMeshChannels: ::std::os::raw::c_uint,
    #[doc = " The morph mesh animation channels. Each channel affects a single mesh."]
    #[doc = "  The array is mNumMorphMeshChannels in size."]
    pub mMorphMeshChannels: *mut *mut aiMeshMorphAnim,
}
#[test]
fn bindgen_test_layout_aiAnimation() {
    assert_eq!(
        ::std::mem::size_of::<aiAnimation>(),
        1096usize,
        concat!("Size of: ", stringify!(aiAnimation))
    );
    assert_eq!(
        ::std::mem::align_of::<aiAnimation>(),
        8usize,
        concat!("Alignment of ", stringify!(aiAnimation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimation>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimation>())).mDuration as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mDuration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimation>())).mTicksPerSecond as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mTicksPerSecond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimation>())).mNumChannels as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mNumChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimation>())).mChannels as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimation>())).mNumMeshChannels as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mNumMeshChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimation>())).mMeshChannels as *const _ as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mMeshChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<aiAnimation>())).mNumMorphMeshChannels as *const _ as usize
        },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mNumMorphMeshChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiAnimation>())).mMorphMeshChannels as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(aiAnimation),
            "::",
            stringify!(mMorphMeshChannels)
        )
    );
}
pub const aiMetadataType_AI_BOOL: aiMetadataType = 0;
pub const aiMetadataType_AI_INT32: aiMetadataType = 1;
pub const aiMetadataType_AI_UINT64: aiMetadataType = 2;
pub const aiMetadataType_AI_FLOAT: aiMetadataType = 3;
pub const aiMetadataType_AI_DOUBLE: aiMetadataType = 4;
pub const aiMetadataType_AI_AISTRING: aiMetadataType = 5;
pub const aiMetadataType_AI_AIVECTOR3D: aiMetadataType = 6;
pub const aiMetadataType_AI_META_MAX: aiMetadataType = 7;
pub const aiMetadataType_FORCE_32BIT: aiMetadataType = 2147483647;
#[doc = " Enum used to distinguish data types"]
pub type aiMetadataType = ::std::os::raw::c_uint;
#[doc = " Metadata entry"]
#[doc = ""]
#[doc = " The type field uniquely identifies the underlying type of the data field"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiMetadataEntry {
    pub mType: aiMetadataType,
    pub mData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aiMetadataEntry() {
    assert_eq!(
        ::std::mem::size_of::<aiMetadataEntry>(),
        16usize,
        concat!("Size of: ", stringify!(aiMetadataEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMetadataEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMetadataEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMetadataEntry>())).mType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMetadataEntry),
            "::",
            stringify!(mType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMetadataEntry>())).mData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMetadataEntry),
            "::",
            stringify!(mData)
        )
    );
}
#[doc = " Container for holding metadata."]
#[doc = ""]
#[doc = " Metadata is a key-value store using string keys and values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiMetadata {
    #[doc = " Length of the mKeys and mValues arrays, respectively"]
    pub mNumProperties: ::std::os::raw::c_uint,
    #[doc = " Arrays of keys, may not be NULL. Entries in this array may not be NULL as well."]
    pub mKeys: *mut aiString,
    #[doc = " Arrays of values, may not be NULL. Entries in this array may be NULL if the"]
    #[doc = " corresponding property key has no assigned value."]
    pub mValues: *mut aiMetadataEntry,
}
#[test]
fn bindgen_test_layout_aiMetadata() {
    assert_eq!(
        ::std::mem::size_of::<aiMetadata>(),
        24usize,
        concat!("Size of: ", stringify!(aiMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<aiMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(aiMetadata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMetadata>())).mNumProperties as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMetadata),
            "::",
            stringify!(mNumProperties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMetadata>())).mKeys as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMetadata),
            "::",
            stringify!(mKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiMetadata>())).mValues as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aiMetadata),
            "::",
            stringify!(mValues)
        )
    );
}
#[doc = " A node in the imported hierarchy."]
#[doc = ""]
#[doc = " Each node has name, a parent node (except for the root node),"]
#[doc = " a transformation relative to its parent and possibly several child nodes."]
#[doc = " Simple file formats don't support hierarchical structures - for these formats"]
#[doc = " the imported scene does consist of only a single root node without children."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aiNode {
    #[doc = " The name of the node."]
    #[doc = ""]
    #[doc = " The name might be empty (length of zero) but all nodes which"]
    #[doc = " need to be referenced by either bones or animations are named."]
    #[doc = " Multiple nodes may have the same name, except for nodes which are referenced"]
    #[doc = " by bones (see #aiBone and #aiMesh::mBones). Their names *must* be unique."]
    #[doc = ""]
    #[doc = " Cameras and lights reference a specific node by name - if there"]
    #[doc = " are multiple nodes with this name, they are assigned to each of them."]
    #[doc = " <br>"]
    #[doc = " There are no limitations with regard to the characters contained in"]
    #[doc = " the name string as it is usually taken directly from the source file."]
    #[doc = ""]
    #[doc = " Implementations should be able to handle tokens such as whitespace, tabs,"]
    #[doc = " line feeds, quotation marks, ampersands etc."]
    #[doc = ""]
    #[doc = " Sometimes assimp introduces new nodes not present in the source file"]
    #[doc = " into the hierarchy (usually out of necessity because sometimes the"]
    #[doc = " source hierarchy format is simply not compatible). Their names are"]
    #[doc = " surrounded by @verbatim <> @endverbatim e.g."]
    #[doc = "  @verbatim<DummyRootNode> @endverbatim."]
    pub mName: aiString,
    #[doc = " The transformation relative to the node's parent."]
    pub mTransformation: aiMatrix4x4,
    #[doc = " Parent node. NULL if this node is the root node."]
    pub mParent: *mut aiNode,
    #[doc = " The number of child nodes of this node."]
    pub mNumChildren: ::std::os::raw::c_uint,
    #[doc = " The child nodes of this node. NULL if mNumChildren is 0."]
    pub mChildren: *mut *mut aiNode,
    #[doc = " The number of meshes of this node."]
    pub mNumMeshes: ::std::os::raw::c_uint,
    #[doc = " The meshes of this node. Each entry is an index into the"]
    #[doc = " mesh list of the #aiScene."]
    pub mMeshes: *mut ::std::os::raw::c_uint,
    #[doc = " Metadata associated with this node or NULL if there is no metadata."]
    #[doc = "  Whether any metadata is generated depends on the source file format. See the"]
    #[doc = " @link importer_notes @endlink page for more information on every source file"]
    #[doc = " format. Importers that don't document any metadata don't write any."]
    pub mMetaData: *mut aiMetadata,
}
#[test]
fn bindgen_test_layout_aiNode() {
    assert_eq!(
        ::std::mem::size_of::<aiNode>(),
        1144usize,
        concat!("Size of: ", stringify!(aiNode))
    );
    assert_eq!(
        ::std::mem::align_of::<aiNode>(),
        8usize,
        concat!("Alignment of ", stringify!(aiNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNode>())).mName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNode),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNode>())).mTransformation as *const _ as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNode),
            "::",
            stringify!(mTransformation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNode>())).mParent as *const _ as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNode),
            "::",
            stringify!(mParent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNode>())).mNumChildren as *const _ as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNode),
            "::",
            stringify!(mNumChildren)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNode>())).mChildren as *const _ as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNode),
            "::",
            stringify!(mChildren)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNode>())).mNumMeshes as *const _ as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNode),
            "::",
            stringify!(mNumMeshes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNode>())).mMeshes as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNode),
            "::",
            stringify!(mMeshes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiNode>())).mMetaData as *const _ as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(aiNode),
            "::",
            stringify!(mMetaData)
        )
    );
}
#[doc = " The root structure of the imported data."]
#[doc = ""]
#[doc = "  Everything that was imported from the given file can be accessed from here."]
#[doc = "  Objects of this class are generally maintained and owned by Assimp, not"]
#[doc = "  by the caller. You shouldn't want to instance it, nor should you ever try to"]
#[doc = "  delete a given scene on your own."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aiScene {
    #[doc = " Any combination of the AI_SCENE_FLAGS_XXX flags. By default"]
    #[doc = " this value is 0, no flags are set. Most applications will"]
    #[doc = " want to reject all scenes with the AI_SCENE_FLAGS_INCOMPLETE"]
    #[doc = " bit set."]
    pub mFlags: ::std::os::raw::c_uint,
    #[doc = " The root node of the hierarchy."]
    #[doc = ""]
    #[doc = " There will always be at least the root node if the import"]
    #[doc = " was successful (and no special flags have been set)."]
    #[doc = " Presence of further nodes depends on the format and content"]
    #[doc = " of the imported file."]
    pub mRootNode: *mut aiNode,
    #[doc = " The number of meshes in the scene."]
    pub mNumMeshes: ::std::os::raw::c_uint,
    #[doc = " The array of meshes."]
    #[doc = ""]
    #[doc = " Use the indices given in the aiNode structure to access"]
    #[doc = " this array. The array is mNumMeshes in size. If the"]
    #[doc = " AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always"]
    #[doc = " be at least ONE material."]
    pub mMeshes: *mut *mut aiMesh,
    #[doc = " The number of materials in the scene."]
    pub mNumMaterials: ::std::os::raw::c_uint,
    #[doc = " The array of materials."]
    #[doc = ""]
    #[doc = " Use the index given in each aiMesh structure to access this"]
    #[doc = " array. The array is mNumMaterials in size. If the"]
    #[doc = " AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always"]
    #[doc = " be at least ONE material."]
    pub mMaterials: *mut *mut aiMaterial,
    #[doc = " The number of animations in the scene."]
    pub mNumAnimations: ::std::os::raw::c_uint,
    #[doc = " The array of animations."]
    #[doc = ""]
    #[doc = " All animations imported from the given file are listed here."]
    #[doc = " The array is mNumAnimations in size."]
    pub mAnimations: *mut *mut aiAnimation,
    #[doc = " The number of textures embedded into the file"]
    pub mNumTextures: ::std::os::raw::c_uint,
    #[doc = " The array of embedded textures."]
    #[doc = ""]
    #[doc = " Not many file formats embed their textures into the file."]
    #[doc = " An example is Quake's MDL format (which is also used by"]
    #[doc = " some GameStudio versions)"]
    pub mTextures: *mut *mut aiTexture,
    #[doc = " The number of light sources in the scene. Light sources"]
    #[doc = " are fully optional, in most cases this attribute will be 0"]
    pub mNumLights: ::std::os::raw::c_uint,
    #[doc = " The array of light sources."]
    #[doc = ""]
    #[doc = " All light sources imported from the given file are"]
    #[doc = " listed here. The array is mNumLights in size."]
    pub mLights: *mut *mut aiLight,
    #[doc = " The number of cameras in the scene. Cameras"]
    #[doc = " are fully optional, in most cases this attribute will be 0"]
    pub mNumCameras: ::std::os::raw::c_uint,
    #[doc = " The array of cameras."]
    #[doc = ""]
    #[doc = " All cameras imported from the given file are listed here."]
    #[doc = " The array is mNumCameras in size. The first camera in the"]
    #[doc = " array (if existing) is the default camera view into"]
    #[doc = " the scene."]
    pub mCameras: *mut *mut aiCamera,
    #[doc = "  @brief  The global metadata assigned to the scene itself."]
    #[doc = ""]
    #[doc = "  This data contains global metadata which belongs to the scene like"]
    #[doc = "  unit-conversions, versions, vendors or other model-specific data. This"]
    #[doc = "  can be used to store format-specific metadata as well."]
    pub mMetaData: *mut aiMetadata,
    pub mPrivate: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_aiScene() {
    assert_eq!(
        ::std::mem::size_of::<aiScene>(),
        128usize,
        concat!("Size of: ", stringify!(aiScene))
    );
    assert_eq!(
        ::std::mem::align_of::<aiScene>(),
        8usize,
        concat!("Alignment of ", stringify!(aiScene))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mRootNode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mRootNode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mNumMeshes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mNumMeshes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mMeshes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mMeshes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mNumMaterials as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mNumMaterials)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mMaterials as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mMaterials)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mNumAnimations as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mNumAnimations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mAnimations as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mAnimations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mNumTextures as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mNumTextures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mTextures as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mTextures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mNumLights as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mNumLights)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mLights as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mLights)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mNumCameras as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mNumCameras)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mCameras as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mCameras)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mMetaData as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mMetaData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aiScene>())).mPrivate as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(aiScene),
            "::",
            stringify!(mPrivate)
        )
    );
}
